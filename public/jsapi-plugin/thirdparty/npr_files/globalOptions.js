/* Copyright (c) Pluck Corporation 2008. This software code and related intellectual property are the property of Pluck Corporation and are licensed for use solely on designated websites. Any distribution, copying, or other use of this intellectual property other than pursuant to a written agreement with Pluck Corporation is strictly prohibited. All Rights Reserved. */
// THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY.

if (typeof(PLUCKSL_GLOBAL_OPTIONS) === 'undefined') {
   var PLUCKSL_GLOBAL_OPTIONS_MAP = {}
   PLUCKSL_GLOBAL_OPTIONS_MAP['System'] = {
      'sitelifeHost': 'http://community.npr.org/',
      'baseUrl': 'http://www.npr.org/',
      'siteLifeBaseUrl': 'http://community.npr.org/ver1.0/',
      'siteLifeScriptsSuffix': 'content/scripts/',
      'groupsSuffix': 'templates/community/group.php',
      'privateMessagingSuffix': 'private_messaging/index.html',
      'personaSuffix': '/templates/community/persona.php',
      'daapiSuffix': 'Direct/Process',
      'flashTunnelUrlSuffix': 'content/swf/PluckFlashDAPIService.swf',
      'flashExpressInstallSuffix': 'assets/expressinstall.swf',
      'photoUploadSuffix': 'Photo/Upload',
      'photoSizeLimit': '2097152',
      'userIdQueryParamName': 'uid',
      'communityGroupCreationUserTier': 'Standard',
      'videoUploadSuffix': 'Video/Upload',
      'loginUrl': 'http://www.npr.org/templates/reg/login.php',
      'loginUrlRedirectQueryParamName': 'returnURL',
      'logoutUrl': 'http://www.npr.org/templates/reg/logout.php',
      'logoutUrlRedirectQueryParamName': 'returnURL',
      'registerUrl': 'http://www.npr.org/templates/reg/',
      'registerUrlRedirectQueryParamName': 'returnURL',
      'facebookApiKey': 'dc20e553940875ced0537034057eb959',
      'discussionEmailSubscriptionEnabled': 'False',
      'forumEmailSubscriptionEnabled': 'False',
      'privateMessagingEnabled': 'False',
      'anonymousUserToReportAbuse': 'True',
      'anonymousUsersCanVoteInPolls': 'False',
      'forumsHtmlEditorEnabled': 'True',
      'forumsHtmlEditorAllowsImages': 'True',
      'privateMessageFriendFilteringEnabled': 'False',
      'viewTrackingEnabled': 'True',
      'enableCommunityGroupPaginationNumbers': 'False',
      'forumViewTrackingEnabled': 'False'
   };
   var plckDecideMemberSite = function(){
      return 'System';
   };
   var PLUCKSL_GLOBAL_OPTIONS = PLUCKSL_GLOBAL_OPTIONS_MAP[plckDecideMemberSite()];
}
/**
 * TrimPath Template. Release 1.0.38.
 * Copyright (C) 2004, 2005 Metaha.
 * 
 * TrimPath Template is licensed under the GNU General Public License
 * and the Apache License, Version 2.0, as follows:
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed WITHOUT ANY WARRANTY; without even the 
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TrimPath;

// TODO: Debugging mode vs stop-on-error mode - runtime flag.
// TODO: Handle || (or) characters and backslashes.
// TODO: Add more modifiers.

(function() {               // Using a closure to keep global namespace clean.
    if (TrimPath == null)
        TrimPath = new Object();
    if (TrimPath.evalEx == null)
        TrimPath.evalEx = function(src) { return eval(src); };

    var UNDEFINED;
    if (Array.prototype.pop == null)  // IE 5.x fix from Igor Poteryaev.
        Array.prototype.pop = function() {
            if (this.length === 0) {return UNDEFINED;}
            return this[--this.length];
        };
    if (Array.prototype.push == null) // IE 5.x fix from Igor Poteryaev.
        Array.prototype.push = function() {
            for (var i = 0; i < arguments.length; ++i) {this[this.length] = arguments[i];}
            return this.length;
        };

    TrimPath.parseTemplate = function(tmplContent, optTmplName, optEtc) {
        if (optEtc == null)
            optEtc = TrimPath.parseTemplate_etc;
        var funcSrc = parse(tmplContent, optTmplName, optEtc);
        var func = TrimPath.evalEx(funcSrc, optTmplName, 1);
        if (func != null)
            return new optEtc.Template(optTmplName, tmplContent, funcSrc, func, optEtc);
        return null;
    }
    
    try {
        String.prototype.process = function(context, optFlags) {
            var template = TrimPath.parseTemplate(this, null);
            if (template != null)
                return template.process(context, optFlags);
            return this;
        }
    } catch (e) { // Swallow exception, such as when String.prototype is sealed.
    }
    
    TrimPath.parseTemplate_etc = {};            // Exposed for extensibility.
    TrimPath.parseTemplate_etc.statementTag = "forelse|for|if|elseif|else|var|macro";
    TrimPath.parseTemplate_etc.statementDef = { // Lookup table for statement tags.
        "if"     : { delta:  1, prefix: "if (", suffix: ") {", paramMin: 1 },
        "else"   : { delta:  0, prefix: "} else {" },
        "elseif" : { delta:  0, prefix: "} else if (", suffix: ") {", paramDefault: "true" },
        "/if"    : { delta: -1, prefix: "}" },
        "for"    : { delta:  1, paramMin: 3, 
                     prefixFunc : function(stmtParts, state, tmplName, etc) {
                        if (stmtParts[2] != "in")
                            throw new etc.ParseError(tmplName, state.line, "bad for loop statement: " + stmtParts.join(' '));
                        var iterVar = stmtParts[1];
                        var listVar = "__LIST__" + iterVar;
                        return [ "var ", listVar, " = ", stmtParts[3], ";",
                             // Fix from Ross Shaull for hash looping, make sure that we have an array of loop lengths to treat like a stack.
                             "var __LENGTH_STACK__;",
                             "if (typeof(__LENGTH_STACK__) == 'undefined' || !__LENGTH_STACK__.length) __LENGTH_STACK__ = new Array();", 
                             "__LENGTH_STACK__[__LENGTH_STACK__.length] = 0;", // Push a new for-loop onto the stack of loop lengths.
                             "if ((", listVar, ") != null) { ",
                             "var ", iterVar, "_ct = 0;",       // iterVar_ct variable, added by B. Bittman     
                             "for (var ", iterVar, "_index in ", listVar, ") { ",
                             iterVar, "_ct++;",
                             "if (typeof(", listVar, "[", iterVar, "_index]) == 'function') {continue;}", // IE 5.x fix from Igor Poteryaev.
                             "__LENGTH_STACK__[__LENGTH_STACK__.length - 1]++;",
                             "var ", iterVar, " = ", listVar, "[", iterVar, "_index];" ].join("");
                     } },
        "forelse" : { delta:  0, prefix: "} } if (__LENGTH_STACK__[__LENGTH_STACK__.length - 1] == 0) { if (", suffix: ") {", paramDefault: "true" },
        "/for"    : { delta: -1, prefix: "} }; delete __LENGTH_STACK__[__LENGTH_STACK__.length - 1];" }, // Remove the just-finished for-loop from the stack of loop lengths.
        "var"     : { delta:  0, prefix: "var ", suffix: ";" },
        "macro"   : { delta:  1, 
                      prefixFunc : function(stmtParts, state, tmplName, etc) {
                          var macroName = stmtParts[1].split('(')[0];
                          return [ "var ", macroName, " = function", 
                                   stmtParts.slice(1).join(' ').substring(macroName.length),
                                   "{ var _OUT_arr = []; var _OUT = { write: function(m) { if (m) _OUT_arr.push(m); } }; " ].join('');
                     } }, 
        "/macro"  : { delta: -1, prefix: " return _OUT_arr.join(''); };" }
    }
    TrimPath.parseTemplate_etc.modifierDef = {
        "eat"        : function(v)    { return ""; },
        "escape"     : function(s)    { return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); },
        "capitalize" : function(s)    { return String(s).toUpperCase(); },
        "default"    : function(s, d) { return s != null ? s : d; }
    }
    TrimPath.parseTemplate_etc.modifierDef.h = TrimPath.parseTemplate_etc.modifierDef.escape;

    TrimPath.parseTemplate_etc.Template = function(tmplName, tmplContent, funcSrc, func, etc) {
        this.process = function(context, flags) {
            if (context == null)
                context = {};
            if (context._MODIFIERS == null)
                context._MODIFIERS = {};
            if (context.defined == null)
                context.defined = function(str) { return (context[str] != undefined); };
            for (var k in etc.modifierDef) {
                if (context._MODIFIERS[k] == null)
                    context._MODIFIERS[k] = etc.modifierDef[k];
            }
            if (flags == null)
                flags = {};
            var resultArr = [];
            var resultOut = { write: function(m) { resultArr.push(m); } };
            try {
                func(resultOut, context, flags);
            } catch (e) {
                if (flags.throwExceptions == true)
                    throw e;
                var result = new String(resultArr.join("") + "[ERROR: " + e.toString() + (e.message ? '; ' + e.message : '') + "]");
                result["exception"] = e;
                return result;
            }
            return resultArr.join("");
        }
        this.name       = tmplName;
        this.source     = tmplContent; 
        this.sourceFunc = funcSrc;
        this.toString   = function() { return "TrimPath.Template [" + tmplName + "]"; }
    }
    TrimPath.parseTemplate_etc.ParseError = function(name, line, message) {
        this.name    = name;
        this.line    = line;
        this.message = message;
    }
    TrimPath.parseTemplate_etc.ParseError.prototype.toString = function() { 
        return ("TrimPath template ParseError in " + this.name + ": line " + this.line + ", " + this.message);
    }
    
    var parse = function(body, tmplName, etc) {
        body = cleanWhiteSpace(body);
        var funcText = [ "var TrimPath_Template_TEMP = function(_OUT, _CONTEXT, _FLAGS) { with (_CONTEXT) {" ];
        var state    = { stack: [], line: 1 };                              // TODO: Fix line number counting.
        var endStmtPrev = -1;
        while (endStmtPrev + 1 < body.length) {
            var begStmt = endStmtPrev;
            // Scan until we find some statement markup.
            begStmt = body.indexOf("{", begStmt + 1);
            while (begStmt >= 0) {
                var endStmt = body.indexOf('}', begStmt + 1);
                var stmt = body.substring(begStmt, endStmt);
                var blockrx = stmt.match(/^\{(cdata|minify|eval)/); // From B. Bittman, minify/eval/cdata implementation.
                if (blockrx) {
                    var blockType = blockrx[1]; 
                    var blockMarkerBeg = begStmt + blockType.length + 1;
                    var blockMarkerEnd = body.indexOf('}', blockMarkerBeg);
                    if (blockMarkerEnd >= 0) {
                        var blockMarker;
                        if( blockMarkerEnd - blockMarkerBeg <= 0 ) {
                            blockMarker = "{/" + blockType + "}";
                        } else {
                            blockMarker = body.substring(blockMarkerBeg + 1, blockMarkerEnd);
                        }                        
                        
                        var blockEnd = body.indexOf(blockMarker, blockMarkerEnd + 1);
                        if (blockEnd >= 0) {                            
                            emitSectionText(body.substring(endStmtPrev + 1, begStmt), funcText);
                            
                            var blockText = body.substring(blockMarkerEnd + 1, blockEnd);
                            if (blockType == 'cdata') {
                                emitText(blockText, funcText);
                            } else if (blockType == 'minify') {
                                emitText(scrubWhiteSpace(blockText), funcText);
                            } else if (blockType == 'eval') {
                                if (blockText != null && blockText.length > 0) // From B. Bittman, eval should not execute until process().
                                    funcText.push('_OUT.write( (function() { ' + blockText + ' })() );');
                            }
                            begStmt = endStmtPrev = blockEnd + blockMarker.length - 1;
                        }
                    }                        
                } else if (body.charAt(begStmt - 1) != '$' &&               // Not an expression or backslashed,
                           body.charAt(begStmt - 1) != '\\') {              // so check if it is a statement tag.
                    var offset = (body.charAt(begStmt + 1) == '/' ? 2 : 1); // Close tags offset of 2 skips '/'.
                                                                            // 10 is larger than maximum statement tag length.
                    if (body.substring(begStmt + offset, begStmt + 10 + offset).search(TrimPath.parseTemplate_etc.statementTag) == 0) 
                        break;                                              // Found a match.
                }
                begStmt = body.indexOf("{", begStmt + 1);
            }
            if (begStmt < 0)                              // In "a{for}c", begStmt will be 1.
                break;
            var endStmt = body.indexOf("}", begStmt + 1); // In "a{for}c", endStmt will be 5.
            if (endStmt < 0)
                break;
            emitSectionText(body.substring(endStmtPrev + 1, begStmt), funcText);
            emitStatement(body.substring(begStmt, endStmt + 1), state, funcText, tmplName, etc);
            endStmtPrev = endStmt;
        }
        emitSectionText(body.substring(endStmtPrev + 1), funcText);
        if (state.stack.length != 0)
            throw new etc.ParseError(tmplName, state.line, "unclosed, unmatched statement(s): " + state.stack.join(","));
        funcText.push("}}; TrimPath_Template_TEMP");
        return funcText.join("");
    }
    
    var emitStatement = function(stmtStr, state, funcText, tmplName, etc) {
        var parts = stmtStr.slice(1, -1).split(' ');
        var stmt = etc.statementDef[parts[0]]; // Here, parts[0] == for/if/else/...
        if (stmt == null) {                    // Not a real statement.
            emitSectionText(stmtStr, funcText);
            return;
        }
        if (stmt.delta < 0) {
            if (state.stack.length <= 0)
                throw new etc.ParseError(tmplName, state.line, "close tag does not match any previous statement: " + stmtStr);
            state.stack.pop();
        } 
        if (stmt.delta > 0)
            state.stack.push(stmtStr);

        if (stmt.paramMin != null &&
            stmt.paramMin >= parts.length)
            throw new etc.ParseError(tmplName, state.line, "statement needs more parameters: " + stmtStr);
        if (stmt.prefixFunc != null)
            funcText.push(stmt.prefixFunc(parts, state, tmplName, etc));
        else 
            funcText.push(stmt.prefix);
        if (stmt.suffix != null) {
            if (parts.length <= 1) {
                if (stmt.paramDefault != null)
                    funcText.push(stmt.paramDefault);
            } else {
                for (var i = 1; i < parts.length; i++) {
                    if (i > 1)
                        funcText.push(' ');
                    funcText.push(parts[i]);
                }
            }
            funcText.push(stmt.suffix);
        }
    }

    var emitSectionText = function(text, funcText) {
        if (text.length <= 0)
            return;
        var nlPrefix = 0;               // Index to first non-newline in prefix.
        var nlSuffix = text.length - 1; // Index to first non-space/tab in suffix.
        while (nlPrefix < text.length && (text.charAt(nlPrefix) == '\n'))
            nlPrefix++;
        while (nlSuffix >= 0 && (text.charAt(nlSuffix) == ' ' || text.charAt(nlSuffix) == '\t'))
            nlSuffix--;
        if (nlSuffix < nlPrefix)
            nlSuffix = nlPrefix;
        if (nlPrefix > 0) {
            funcText.push('if (_FLAGS.keepWhitespace == true) _OUT.write("');
            var s = text.substring(0, nlPrefix).replace('\n', '\\n'); // A macro IE fix from BJessen.
            if (s.charAt(s.length - 1) == '\n')
            	s = s.substring(0, s.length - 1);
            funcText.push(s);
            funcText.push('");');
        }
        var lines = text.substring(nlPrefix, nlSuffix + 1).split('\n');
        for (var i = 0; i < lines.length; i++) {
            emitSectionTextLine(lines[i], funcText);
            if (i < lines.length - 1)
                funcText.push('_OUT.write("\\n");\n');
        }
        if (nlSuffix + 1 < text.length) {
            funcText.push('if (_FLAGS.keepWhitespace == true) _OUT.write("');
            var s = text.substring(nlSuffix + 1).replace('\n', '\\n');
            if (s.charAt(s.length - 1) == '\n')
            	s = s.substring(0, s.length - 1);
            funcText.push(s);
            funcText.push('");');
        }
    }
    
    var emitSectionTextLine = function(line, funcText) {
        var endMarkPrev = '}';
        var endExprPrev = -1;
        while (endExprPrev + endMarkPrev.length < line.length) {
            var begMark = "${", endMark = "}";
            var begExpr = line.indexOf(begMark, endExprPrev + endMarkPrev.length); // In "a${b}c", begExpr == 1
            if (begExpr < 0)
                break;
            if (line.charAt(begExpr + 2) == '%') {
                begMark = "${%";
                endMark = "%}";
            }
            var endExpr = line.indexOf(endMark, begExpr + begMark.length);         // In "a${b}c", endExpr == 4;
            if (endExpr < 0)
                break;
            emitText(line.substring(endExprPrev + endMarkPrev.length, begExpr), funcText);                
            // Example: exprs == 'firstName|default:"John Doe"|capitalize'.split('|')
            var exprArr = line.substring(begExpr + begMark.length, endExpr).replace(/\|\|/g, "#@@#").split('|');
            for (var k in exprArr) {
                if (exprArr[k].replace) // IE 5.x fix from Igor Poteryaev.
                    exprArr[k] = exprArr[k].replace(/#@@#/g, '||');
            }
            funcText.push('_OUT.write(');
            emitExpression(exprArr, exprArr.length - 1, funcText); 
            funcText.push(');');
            endExprPrev = endExpr;
            endMarkPrev = endMark;
        }
        emitText(line.substring(endExprPrev + endMarkPrev.length), funcText); 
    }
    
    var emitText = function(text, funcText) {
        if (text == null ||
            text.length <= 0)
            return;
        text = text.replace(/\\/g, '\\\\');
        text = text.replace(/\n/g, '\\n');
        text = text.replace(/"/g,  '\\"');
        funcText.push('_OUT.write("');
        funcText.push(text);
        funcText.push('");');
    }
    
    var emitExpression = function(exprArr, index, funcText) {
        // Ex: foo|a:x|b:y1,y2|c:z1,z2 is emitted as c(b(a(foo,x),y1,y2),z1,z2)
        var expr = exprArr[index]; // Ex: exprArr == [firstName,capitalize,default:"John Doe"]
        if (index <= 0) {          // Ex: expr    == 'default:"John Doe"'
            funcText.push(expr);
            return;
        }
        var parts = expr.split(':');
        funcText.push('_MODIFIERS["');
        funcText.push(parts[0]); // The parts[0] is a modifier function name, like capitalize.
        funcText.push('"](');
        emitExpression(exprArr, index - 1, funcText);
        if (parts.length > 1) {
            funcText.push(',');
            funcText.push(parts[1]);
        }
        funcText.push(')');
    }

    var cleanWhiteSpace = function(result) {
        result = result.replace(/\t/g,   "    ");
        result = result.replace(/\r\n/g, "\n");
        result = result.replace(/\r/g,   "\n");
        result = result.replace(/^(\s*\S*(\s+\S+)*)\s*$/, '$1'); // Right trim by Igor Poteryaev.
        return result;
    }

    var scrubWhiteSpace = function(result) {
        result = result.replace(/^\s+/g,   "");
        result = result.replace(/\s+$/g,   "");
        result = result.replace(/\s+/g,   " ");
        result = result.replace(/^(\s*\S*(\s+\S+)*)\s*$/, '$1'); // Right trim by Igor Poteryaev.
        return result;
    }

    // The DOM helper functions depend on DOM/DHTML, so they only work in a browser.
    // However, these are not considered core to the engine.
    //
    TrimPath.parseDOMTemplate = function(elementId, optDocument, optEtc) {
        if (optDocument == null)
            optDocument = document;
        var element = optDocument.getElementById(elementId);
        var content = element.value;     // Like textarea.value.
        if (content == null)
            content = element.innerHTML; // Like textarea.innerHTML.
        content = content.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        return TrimPath.parseTemplate(content, elementId, optEtc);
    }

    TrimPath.processDOMTemplate = function(elementId, context, optFlags, optDocument, optEtc) {
        return TrimPath.parseDOMTemplate(elementId, optDocument, optEtc).process(context, optFlags);
    }
}) ();
/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.6.0
*/
if(typeof YAHOO=="undefined"||!YAHOO){var YAHOO={};}YAHOO.namespace=function(){var A=arguments,E=null,C,B,D;for(C=0;C<A.length;C=C+1){D=A[C].split(".");E=YAHOO;for(B=(D[0]=="YAHOO")?1:0;B<D.length;B=B+1){E[D[B]]=E[D[B]]||{};E=E[D[B]];}}return E;};YAHOO.log=function(D,A,C){var B=YAHOO.widget.Logger;if(B&&B.log){return B.log(D,A,C);}else{return false;}};YAHOO.register=function(A,E,D){var I=YAHOO.env.modules;if(!I[A]){I[A]={versions:[],builds:[]};}var B=I[A],H=D.version,G=D.build,F=YAHOO.env.listeners;B.name=A;B.version=H;B.build=G;B.versions.push(H);B.builds.push(G);B.mainClass=E;for(var C=0;C<F.length;C=C+1){F[C](B);}if(E){E.VERSION=H;E.BUILD=G;}else{YAHOO.log("mainClass is undefined for module "+A,"warn");}};YAHOO.env=YAHOO.env||{modules:[],listeners:[]};YAHOO.env.getVersion=function(A){return YAHOO.env.modules[A]||null;};YAHOO.env.ua=function(){var C={ie:0,opera:0,gecko:0,webkit:0,mobile:null,air:0};var B=navigator.userAgent,A;if((/KHTML/).test(B)){C.webkit=1;}A=B.match(/AppleWebKit\/([^\s]*)/);if(A&&A[1]){C.webkit=parseFloat(A[1]);if(/ Mobile\//.test(B)){C.mobile="Apple";}else{A=B.match(/NokiaN[^\/]*/);if(A){C.mobile=A[0];}}A=B.match(/AdobeAIR\/([^\s]*)/);if(A){C.air=A[0];}}if(!C.webkit){A=B.match(/Opera[\s\/]([^\s]*)/);if(A&&A[1]){C.opera=parseFloat(A[1]);A=B.match(/Opera Mini[^;]*/);if(A){C.mobile=A[0];}}else{A=B.match(/MSIE\s([^;]*)/);if(A&&A[1]){C.ie=parseFloat(A[1]);}else{A=B.match(/Gecko\/([^\s]*)/);if(A){C.gecko=1;A=B.match(/rv:([^\s\)]*)/);if(A&&A[1]){C.gecko=parseFloat(A[1]);}}}}}return C;}();(function(){YAHOO.namespace("util","widget","example");if("undefined"!==typeof YAHOO_config){var B=YAHOO_config.listener,A=YAHOO.env.listeners,D=true,C;if(B){for(C=0;C<A.length;C=C+1){if(A[C]==B){D=false;break;}}if(D){A.push(B);}}}})();YAHOO.lang=YAHOO.lang||{};(function(){var A=YAHOO.lang,C=["toString","valueOf"],B={isArray:function(D){if(D){return A.isNumber(D.length)&&A.isFunction(D.splice);}return false;},isBoolean:function(D){return typeof D==="boolean";},isFunction:function(D){return typeof D==="function";},isNull:function(D){return D===null;},isNumber:function(D){return typeof D==="number"&&isFinite(D);},isObject:function(D){return(D&&(typeof D==="object"||A.isFunction(D)))||false;},isString:function(D){return typeof D==="string";},isUndefined:function(D){return typeof D==="undefined";},_IEEnumFix:(YAHOO.env.ua.ie)?function(F,E){for(var D=0;D<C.length;D=D+1){var H=C[D],G=E[H];if(A.isFunction(G)&&G!=Object.prototype[H]){F[H]=G;}}}:function(){},extend:function(H,I,G){if(!I||!H){throw new Error("extend failed, please check that "+"all dependencies are included.");}var E=function(){};E.prototype=I.prototype;H.prototype=new E();H.prototype.constructor=H;H.superclass=I.prototype;if(I.prototype.constructor==Object.prototype.constructor){I.prototype.constructor=I;}if(G){for(var D in G){if(A.hasOwnProperty(G,D)){H.prototype[D]=G[D];}}A._IEEnumFix(H.prototype,G);}},augmentObject:function(H,G){if(!G||!H){throw new Error("Absorb failed, verify dependencies.");}var D=arguments,F,I,E=D[2];if(E&&E!==true){for(F=2;F<D.length;F=F+1){H[D[F]]=G[D[F]];}}else{for(I in G){if(E||!(I in H)){H[I]=G[I];}}A._IEEnumFix(H,G);}},augmentProto:function(G,F){if(!F||!G){throw new Error("Augment failed, verify dependencies.");}var D=[G.prototype,F.prototype];for(var E=2;E<arguments.length;E=E+1){D.push(arguments[E]);}A.augmentObject.apply(this,D);},dump:function(D,I){var F,H,K=[],L="{...}",E="f(){...}",J=", ",G=" => ";if(!A.isObject(D)){return D+"";}else{if(D instanceof Date||("nodeType" in D&&"tagName" in D)){return D;}else{if(A.isFunction(D)){return E;}}}I=(A.isNumber(I))?I:3;if(A.isArray(D)){K.push("[");for(F=0,H=D.length;F<H;F=F+1){if(A.isObject(D[F])){K.push((I>0)?A.dump(D[F],I-1):L);}else{K.push(D[F]);}K.push(J);}if(K.length>1){K.pop();}K.push("]");}else{K.push("{");for(F in D){if(A.hasOwnProperty(D,F)){K.push(F+G);if(A.isObject(D[F])){K.push((I>0)?A.dump(D[F],I-1):L);}else{K.push(D[F]);}K.push(J);}}if(K.length>1){K.pop();}K.push("}");}return K.join("");},substitute:function(S,E,L){var I,H,G,O,P,R,N=[],F,J="dump",M=" ",D="{",Q="}";for(;;){I=S.lastIndexOf(D);if(I<0){break;}H=S.indexOf(Q,I);if(I+1>=H){break;}F=S.substring(I+1,H);O=F;R=null;G=O.indexOf(M);if(G>-1){R=O.substring(G+1);O=O.substring(0,G);}P=E[O];if(L){P=L(O,P,R);}if(A.isObject(P)){if(A.isArray(P)){P=A.dump(P,parseInt(R,10));}else{R=R||"";var K=R.indexOf(J);if(K>-1){R=R.substring(4);}if(P.toString===Object.prototype.toString||K>-1){P=A.dump(P,parseInt(R,10));}else{P=P.toString();}}}else{if(!A.isString(P)&&!A.isNumber(P)){P="~-"+N.length+"-~";N[N.length]=F;}}S=S.substring(0,I)+P+S.substring(H+1);}for(I=N.length-1;I>=0;I=I-1){S=S.replace(new RegExp("~-"+I+"-~"),"{"+N[I]+"}","g");}return S;},trim:function(D){try{return D.replace(/^\s+|\s+$/g,"");}catch(E){return D;}},merge:function(){var G={},E=arguments;for(var F=0,D=E.length;F<D;F=F+1){A.augmentObject(G,E[F],true);}return G;},later:function(K,E,L,G,H){K=K||0;E=E||{};var F=L,J=G,I,D;if(A.isString(L)){F=E[L];}if(!F){throw new TypeError("method undefined");}if(!A.isArray(J)){J=[G];}I=function(){F.apply(E,J);};D=(H)?setInterval(I,K):setTimeout(I,K);return{interval:H,cancel:function(){if(this.interval){clearInterval(D);}else{clearTimeout(D);}}};},isValue:function(D){return(A.isObject(D)||A.isString(D)||A.isNumber(D)||A.isBoolean(D));}};A.hasOwnProperty=(Object.prototype.hasOwnProperty)?function(D,E){return D&&D.hasOwnProperty(E);}:function(D,E){return !A.isUndefined(D[E])&&D.constructor.prototype[E]!==D[E];};B.augmentObject(A,B,true);YAHOO.util.Lang=A;A.augment=A.augmentProto;YAHOO.augment=A.augmentProto;YAHOO.extend=A.extend;})();YAHOO.register("yahoo",YAHOO,{version:"2.6.0",build:"1321"});/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.6.0
*/
YAHOO.lang.JSON=(function(){var l=YAHOO.lang,_UNICODE_EXCEPTIONS=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,_ESCAPES=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,_VALUES=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,_BRACKETS=/(?:^|:|,)(?:\s*\[)+/g,_INVALID=/^[\],:{}\s]*$/,_SPECIAL_CHARS=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,_CHARS={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};function _revive(data,reviver){var walk=function(o,key){var k,v,value=o[key];if(value&&typeof value==="object"){for(k in value){if(l.hasOwnProperty(value,k)){v=walk(value,k);if(v===undefined){delete value[k];}else{value[k]=v;}}}}return reviver.call(o,key,value);};return typeof reviver==="function"?walk({"":data},""):data;}function _char(c){if(!_CHARS[c]){_CHARS[c]="\\u"+("0000"+(+(c.charCodeAt(0))).toString(16)).slice(-4);}return _CHARS[c];}function _prepare(s){return s.replace(_UNICODE_EXCEPTIONS,_char);}function _isValid(str){return l.isString(str)&&_INVALID.test(str.replace(_ESCAPES,"@").replace(_VALUES,"]").replace(_BRACKETS,""));}function _string(s){return'"'+s.replace(_SPECIAL_CHARS,_char)+'"';}function _stringify(h,key,d,w,pstack){var o=typeof w==="function"?w.call(h,key,h[key]):h[key],i,len,j,k,v,isArray,a;if(o instanceof Date){o=l.JSON.dateToString(o);}else{if(o instanceof String||o instanceof Boolean||o instanceof Number){o=o.valueOf();}}switch(typeof o){case"string":return _string(o);case"number":return isFinite(o)?String(o):"null";case"boolean":return String(o);case"object":if(o===null){return"null";}for(i=pstack.length-1;i>=0;--i){if(pstack[i]===o){return"null";}}pstack[pstack.length]=o;a=[];isArray=l.isArray(o);if(d>0){if(isArray){for(i=o.length-1;i>=0;--i){a[i]=_stringify(o,i,d-1,w,pstack)||"null";}}else{j=0;if(l.isArray(w)){for(i=0,len=w.length;i<len;++i){k=w[i];v=_stringify(o,k,d-1,w,pstack);if(v){a[j++]=_string(k)+":"+v;}}}else{for(k in o){if(typeof k==="string"&&l.hasOwnProperty(o,k)){v=_stringify(o,k,d-1,w,pstack);if(v){a[j++]=_string(k)+":"+v;}}}}a.sort();}}pstack.pop();return isArray?"["+a.join(",")+"]":"{"+a.join(",")+"}";}return undefined;}return{isValid:function(s){return _isValid(_prepare(s));},parse:function(s,reviver){s=_prepare(s);if(_isValid(s)){return _revive(eval("("+s+")"),reviver);}throw new SyntaxError("parseJSON");},stringify:function(o,w,d){if(o!==undefined){if(l.isArray(w)){w=(function(a){var uniq=[],map={},v,i,j,len;for(i=0,j=0,len=a.length;i<len;++i){v=a[i];if(typeof v==="string"&&map[v]===undefined){uniq[(map[v]=j++)]=v;}}return uniq;})(w);}d=d>=0?d:1/0;return _stringify({"":o},"",d,w,[]);}return undefined;},dateToString:function(d){function _zeroPad(v){return v<10?"0"+v:v;}return d.getUTCFullYear()+"-"+_zeroPad(d.getUTCMonth()+1)+"-"+_zeroPad(d.getUTCDate())+"T"+_zeroPad(d.getUTCHours())+":"+_zeroPad(d.getUTCMinutes())+":"+_zeroPad(d.getUTCSeconds())+"Z";},stringToDate:function(str){if(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/.test(str)){var d=new Date();d.setUTCFullYear(RegExp.$1,(RegExp.$2|0)-1,RegExp.$3);d.setUTCHours(RegExp.$4,RegExp.$5,RegExp.$6);return d;}return str;}};})();YAHOO.register("json",YAHOO.lang.JSON,{version:"2.6.0",build:"1321"});if (typeof(RequestBatch) === 'undefined') {
    RequestBatch = function() {
      this.initialize.apply(this, arguments);
    };
    // for unique id
    var counter = 0;

    // how many requests are still pending?
    var pendingRequests = 0;

    function DirectAccessErrorHandler(msg,ex){
    //alert(msg);
    }
    (function() {
    
    var isIE = (navigator.userAgent.indexOf('MSIE')!= -1 && navigator.userAgent.indexOf('Opera') == -1);
        
    var maxUrlLength = isIE ? 2083 : 4000;
    
    var jsonpmax = typeof PLUCK_JSONPMAX !== 'undefined' ? PLUCK_JSONPMAX : null;
    var m = document.location.toString().match(/PLUCK_JSONPMAX=([0-9]+)/);
    if (m && m.length > 0) {
      jsonpmax = m[1];
    }
    if (jsonpmax) {
      maxUrlLength = jsonpmax;
    }
    
    function buildJsonpUrl(serverUrl, encodedJsonString, callbackName, chunkToken, chunksRemaining) {
      var separator = serverUrl.indexOf('?') == -1 ? "?" : "&";
      // use Jsonp endpoint instead of Process
      serverUrl = serverUrl.replace('/Process', '/Jsonp') + separator + "r=" + encodedJsonString + '&cb=' + callbackName;
      if (chunkToken) {
        serverUrl = serverUrl + '&ctk=' + chunkToken + '&crm=' + chunksRemaining;
      }
      return serverUrl;
    }

    function useJsonp(serverUrl, jsonString, callbackName) {
      // use Jsonp endpoint instead of Process
      serverUrl = buildJsonpUrl(serverUrl, encodeURIComponent(jsonString), callbackName);
      if (serverUrl.length < maxUrlLength) {
          return serverUrl;
      }
      return false;
    }
        
    function getJsonpChunks(serverUrl, jsonString, callbackName) {
      // determine the max length for a chunk by subtracting the fully built request url that will
      // be generated and subtracting another 100 for chunktoken/overhead
      var maxChunkLength = maxUrlLength - buildJsonpUrl(serverUrl, '', callbackName, '', false).length - 100;
      var chunks = [];
      while (jsonString.length > 0) {
        var chunk = "";
        var chunkEncoded = "";

        var chunk = jsonString.substr(0, maxChunkLength);
        var chunkEncoded = encodeURIComponent(chunk);

        while (chunkEncoded.length > maxChunkLength) { 
          // Chunk is too big after encoding.
          var chunkDiff = chunkEncoded.length - maxChunkLength;
          chunk = jsonString.substr(0, chunk.length - chunkDiff);
          chunkEncoded = encodeURIComponent(chunk);
        }

        chunks.push(chunkEncoded);
        jsonString = jsonString.substr(chunk.length);
      }
      return chunks;
        }
        
        // Cookie and HTTP Param manipulations
        // generates a list of user keys
        function getCurrentUserFromCookie() {
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
		            while (c.charAt(0) === " ") c = c.substring(1, c.length);
		            var eqIndex = c.indexOf("=");
		            if (eqIndex > 0) {
			              name = c.substring(0, eqIndex);
			              value = c.substring(eqIndex + 1);
			              if (name.toLowerCase() == 'hd') {
			                  value = unescape(value);
			                  value = value.split('|');
        		            	
			                  return value[0];
			              }
                }
            }
            return null;
        }
        
        function createSrcUrl(baseUrl, url, userId, gcid, currentTime) { 
            var regexstring = /\DDirect\/Process\?\w\S*/;
            myregexp = new RegExp(regexstring);
            baseUrl = baseUrl.indexOf('?') == -1 ? baseUrl.replace('/Direct/Process', '/Stats/Tracker.gif') : baseUrl.replace(myregexp, '/Stats/Tracker.gif');
            
            return srcUrl = baseUrl + "?plckUrl=" + encodeURIComponent(url) + "&plckUserId=" + userId + "&plckGcid=" + gcid + "&plckCurrentTime=" + currentTime;
        }

        // the core object to request batches
        RequestBatch.prototype = {
            initialize: function() {
                this.UniqueId = counter++;
                this.Requests = new Array()
            },
            
            gcid: "daapiCall",
            
            InsertTrackerNode: function(serverUrl, requestUrl, userIdTrckr, gcid, currentTime) {
				if (document.getElementById('slImgNodeTrckr') === null) {
					var trackImgNode = document.createElement('img');
					trackImgNode.setAttribute('id', "slImgNodeTrckr");
					trackImgNode.src = createSrcUrl(serverUrl, requestUrl, userIdTrckr, gcid, currentTime);
					if (trackImgNode.style.setAttribute) {
						trackImgNode.style.setAttribute('display', 'none');
					} else {
						trackImgNode.setAttribute('style', 'display:none');
					}
					document.getElementsByTagName('body')[0].appendChild (trackImgNode);
				}
            },
            
            InitializeTracking: function(serverUrl) {
				// create a request url for stats controller
                var requestUrl = location.href;
                var userId = getCurrentUserFromCookie();
                var d = new Date();
                var me = this;
                
                // We are using jQuery's object detection to determine if the browser is ready for us
				// to insert our stat tracker node.
				// Mozilla, Opera and webkit nightlies currently support this event
				if (document.addEventListener) {
					// Use the handy event callback
					document.addEventListener( "DOMContentLoaded", function(){
						document.removeEventListener( "DOMContentLoaded", arguments.callee, false );
						me.InsertTrackerNode(serverUrl, requestUrl, userId, me.gcid, d.getTime());
					}, false );
					
				// If IE event model is used
				} else if (document.attachEvent) {						
					// ensure firing before onload,
					// maybe late but safe also for iframes
					document.attachEvent("onreadystatechange", function(){
						if ( document.readyState === "complete" ) {
							document.detachEvent( "onreadystatechange", arguments.callee );
							me.InsertTrackerNode(serverUrl, requestUrl, userId, me.gcid, d.getTime());
						}
					});

					// If IE and not an iframe
					// continually check to see if the document is ready
					if ( document.documentElement.doScroll && window == window.top ) (function(){

						try {
							// If IE is used, use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							document.documentElement.doScroll("left");
						} catch( error ) {
							setTimeout( arguments.callee, 0 );
							return;
						}

						// and execute any waiting functions
						me.InsertTrackerNode(serverUrl, requestUrl, userId, me.gcid, d.getTime());
					})();
				}
            },

            HasTemplate: function() {
                return typeof (this["Template"]) != "undefined";
            },

            AddToRequest: function(requestThis) {
                this.Requests[this.Requests.length] = requestThis;
            },
            
            BeginRequest: function(serverUrl, callback) {
                pendingRequests++;

                if (!RequestBatch.callbacks) {
                    RequestBatch.callbacks = {};
                }

                var jsonString = YAHOO.lang.JSON.stringify(this), ie = (navigator.userAgent.indexOf('MSIE')!= -1 && navigator.userAgent.indexOf('Opera') == -1);
                if (ie && !RequestBatch.container) { // forcibly take this route only for ie
                    var body = document.body, div;
                    RequestBatch.container = div = body.insertBefore(document.createElement('div'), body.firstChild);
                    div.style.height = div.style.width = div.style.margin = div.style.padding = 0;
                    div.style.visibility = div.style.overflow = 'hidden';
                    div.style.display = 'none';
                }
                // generate our callback function that will call their callback function via closure semantics
                var daapiCallbackName = 'daapiCallback' + this.UniqueId;
                var thisRequest = this;
	        var registeredCallbackName = 'RequestBatch.callbacks.' + daapiCallbackName;
	        var chunking = null;
	        var nextChunkUrl = function() {
	          if (chunking != null && chunking.chunks.length > 0) {
	            var chunk = chunking.chunks.shift();
	            var remaining = chunking.chunks.length;
	            return buildJsonpUrl(serverUrl, chunk, registeredCallbackName, chunking.token, remaining);
	          }
	          return null;
	        };
	                
	        var jsonpServerUrl = useJsonp(serverUrl, jsonString, registeredCallbackName) || null;
	        if (jsonpServerUrl == null) {
	          chunking = { "token": "i", "chunks": getJsonpChunks(serverUrl, jsonString, registeredCallbackName) };
	          jsonpServerUrl = nextChunkUrl();
	        }
	                
	        var callJsonpServerUrl = function(url) {
	          // insert script node with callback function = daapiCallbackName
	          var jsonpScriptNode = document.createElement('script');
	          jsonpScriptNode.type = "text/javascript";
	          jsonpScriptNode.src = url;
	          var headElem = document.getElementsByTagName('head')[0];
	          RequestBatch.callbacks[daapiCallbackName] = (function(headElem, scriptNode) {
	            return function(responses) {
	              if (responses.hasOwnProperty('chunkToken')) {
	                if (!responses.error && chunking != null && chunking.chunks.length > 0) {
	                  chunking.token = responses.chunkToken;
	                  callJsonpServerUrl(nextChunkUrl());
	                } else {
	                  // error
	                }
	              } else if (thisRequest.HasTemplate()) {
	                callback(responses);
	              } else {
	                callback(responses.ResponseBatch);
	              }
	              // clean up after ourselves
	              headElem = scriptNode = null;
	            }
	          })(callback, headElem, jsonpScriptNode);
	          headElem.appendChild(jsonpScriptNode);
	        };
	        callJsonpServerUrl(jsonpServerUrl);
                // Insert tracker image node for stat tracking.
                if (PLUCKSL_GLOBAL_OPTIONS.viewTrackingEnabled) {
                    thisRequest.InitializeTracking(serverUrl);
                }
                // in case they reuse the requestbatch
                this.UniqueId = counter++;
            }
        };
    })();
}

function generateForm(formId, serverUrl, inputVal) {
    // create the form
	var form = document.createElement("form");
	form.acceptCharset = "UTF-8";
	form.name = "f" + formId;
	form.id = "f" + formId;
	form.action = serverUrl;

	// create the input element on the form
	var inputElem = document.createElement("input");
	inputElem.name = "jsonRequest";
	inputElem.type = "hidden";
	inputElem.value = inputVal;
	form.appendChild(inputElem);

	// Firefox has a behavior on refresh that displays a popup confirming that is it reloading a form.
	// We work around this by attempting to perform a get action if the size is below a threshold, else
	// we will run as a post
	form.method = "post";
    if(navigator.userAgent.toLowerCase().indexOf('firefox') != -1) {
        var separator = serverUrl.indexOf('?') == -1 ? "?" : "&";
        var fullRequestURL = serverUrl + separator + "jsonRequest="+ escape(inputVal);
        if (fullRequestURL.length < 4000) {
            // we plan to perform a get, so we need to parse the sid out of the url and place it
            // inside the form
            var sidPos = serverUrl.indexOf('sid=');
            if (sidPos != -1) {
                var endPos = serverUrl.indexOf('&', sidPos);
                var sid = serverUrl.substring(sidPos + 'sid='.length, endPos == -1 ? serverUrl.length : endPos);
	            var sidInputElem = document.createElement("input");
	            sidInputElem.name = "sid";
	            sidInputElem.type = "hidden";
	            sidInputElem.value = sid;
	            form.appendChild(sidInputElem);
	            // remove the sid from the url
	            form.action = serverUrl.substring(0, sidPos-1);
            }
            form.method = "get";
        }
    }

	(RequestBatch.container || document.body).appendChild(form);
	return form;
}

function processResponse(callback, request, isTemplated)
{
    pendingRequests--;
    try {
        if (isTemplated) {
            callback(request.ResponseText);
        } else {
            var jsonResponse = unescape(request.responseText);
            jsonResponse = jsonResponse.replace(/\\\>/g, ">");
            var responseObject = YAHOO.lang.JSON.parse(jsonResponse);
            try {
                callback(responseObject.ResponseBatch);
            } catch (e) {
                DirectAccessErrorHandler("exception during client callback", e);
            }
        }
    } catch (e) {
        DirectAccessErrorHandler("exception during processResponse", e);
    }
}

function getPendingRequestCount()
{
    return pendingRequests;
}

// ------------------------------------------------------------------------------------
// This file contains all the request type objects for the SiteLife JSON Direct API.
// Create instances of these objects, place them in a RequestBatch, and send them off.
// ------------------------------------------------------------------------------------

(function() { // wrapped in a function to keep the Class variable out of the global scope
    var Class = function() {
        return function() {
            this.initialize.apply(this, arguments);
        }
    };
    // Identify a user
    UserKey = Class();
    UserKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.UserKey = data;
        }
    };
    // Identify a comment
    CommentKey = Class();
    CommentKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.CommentKey = data;
        }
    };
    // Identify an article
    ArticleKey = Class();
    ArticleKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.ArticleKey = data;
        }
    };

    // Identify a persona message
    PersonaMessageKey = Class();
    PersonaMessageKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.PersonaMessageKey = data;
        }
    };

    // Identify a review
    ReviewKey = Class();
    ReviewKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.ReviewKey = data;
        }
    };

    // Identify a gallery
    GalleryKey = Class();
    GalleryKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.GalleryKey = data;
        }
    };

    // Identify a photo
    PhotoKey = Class();
    PhotoKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.PhotoKey = data;
        }
    };

    // Identify a video
    VideoKey = Class();
    VideoKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.VideoKey = data;
        }
    };

    // Identify a blog with this blog key
    BlogKey = Class();
    BlogKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.BlogKey = data;
        }
    };

    // Identify a blog post with this blog post key
    BlogPostKey = Class();
    BlogPostKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.BlogPostKey = data;
        }
    };

    // Identify a custom item with this CustomItemKey
    CustomItemKey = Class();
    CustomItemKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.CustomItemKey = data;
        }
    };

    // Identify a custom collection with this CustomCollectionKey
    CustomCollectionKey = Class();
    CustomCollectionKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.CustomCollectionKey = data;
        }
    };


    // Identify a Forum Category
    ForumCategoryKey = Class();
    ForumCategoryKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.ForumCategoryKey = data;
        }
    };

    // Identify a Forum
    ForumKey = Class();
    ForumKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.ForumKey = data;
        }
    };

    // Identify a forum discussion with this DiscussionKey
    DiscussionKey = Class();
    DiscussionKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.DiscussionKey = data;
        }
    };

    // Identify a Forum Post
    ForumPostKey = Class();
    ForumPostKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.ForumPostKey = data;
        }
    };

    // Identify an Event
    EventKey = Class();
    EventKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.EventKey = data;
        }
    };

    // Identify an Event
    EventSetKey = Class();
    EventSetKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.EventSetKey = data;
        }
    };

    // Identify a Community Group
    CommunityGroupKey = Class();
    CommunityGroupKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.CommunityGroupKey = data;
        }
    };

    // Identify a CommunityGroup Membership
    CommunityGroupMembershipKey = Class();
    CommunityGroupMembershipKey.prototype = {
        initialize: function(communityGroupKey, userKey) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.UserKey = userKey;
            this.CommunityGroupMembershipKey = data;
        }
    };


    // Identify a CommunityGroup Invitation
    CommunityGroupInvitationKey = Class();
    CommunityGroupInvitationKey.prototype = {
        initialize: function(communityGroupKey, userKey) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.UserKey = userKey;
            this.CommunityGroupInvitationKey = data;
        }
    };

    // Identify a CommunityGroup Registrant
    CommunityGroupRegistrantKey = Class();
    CommunityGroupRegistrantKey.prototype = {
        initialize: function(communityGroupKey, userKey) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.UserKey = userKey;
            this.CommunityGroupRegistrantKey = data;
        }
    };

    // Identify a CommunityGroup Banned User
    CommunityGroupBannedUserKey = Class();
    CommunityGroupBannedUserKey.prototype = {
        initialize: function(communityGroupKey, userKey) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.UserKey = userKey;
            this.CommunityGroupBannedUserKey = data;
        }
    };
    
    
    PollKey = Class();
    PollKey.prototype = {
        initialize: function(pollKey) {
            var data = new Object();
            data.Key = pollKey;
            this.PollKey = data;
        }
    }

    // Points/Badging
    BadgeFamilyKey = Class();
    BadgeFamilyKey.prototype = {
        initialize: function(badgeFamilyKey) {
            var data = new Object();
            data.Key = badgeFamilyKey;
            this.BadgeFamilyKey = data;
        }
    }

    LeaderboardKey = Class();
    LeaderboardKey.prototype = {
        initialize: function(leaderboardKey) {
            var data = new Object();
            data.Key = leaderboardKey;
            this.LeaderboardKey = data;
        }
    }
    
    FeedActivityKey = Class();
    FeedActivityKey.prototype = {
        initialize: function(feedActivityKey){
            var data = new Object();
            data.Key = feedActivityKey;
            this.FeedActivityKey = data;
        }
    }
    
    RatingsReferenceKey = Class();
    RatingsReferenceKey.prototype = {
        initialize: function(ratingsReferenceKey){
            var data = new Object();
            data.Key = ratingsReferenceKey;
            this.RatingsReferenceKey = data;
        }
    }

    // Wrapper to request a comment page
    CommentPage = Class();
    CommentPage.prototype = {
        initialize: function(articleKey, numberPerPage, onPage, sort, findCommentKey) {
            var data = new Object();
            data.ArticleKey = articleKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            data.FindCommentKey = findCommentKey;
            this.CommentPage = data;
        }
    };

    // Wrapper to request a persona message page
    PersonaMessagePage = Class();
    PersonaMessagePage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.PersonaMessagePage = data;
        }
    };

    // Wrapper to request a review page
    ReviewPage = Class();
    ReviewPage.prototype = {
        initialize: function(articleKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.ArticleKey = articleKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.ReviewPage = data;
        }
    };

    // wrapper to request a page of reviews by user
    UserReviewPage = Class();
    UserReviewPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.UserReviewPage = data;
        }
    };

    // Wrapper of types a gallery can contain
    MediaType = Class();
    MediaType.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.MediaType = data;
        }
    };
    // Wrapper to request a page of public galleries
    PublicGalleryPage = Class();
    PublicGalleryPage.prototype = {
        initialize: function(numberPerPage, onPage, mediaType) {
            var data = new Object();
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.MediaType = mediaType;
            this.PublicGalleryPage = data;
        }
    };
    // Wrapper to request a page of user galleries
    UserGalleryPage = Class();
    UserGalleryPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, mediaType) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.MediaType = mediaType;
            this.UserGalleryPage = data;
        }
    };
    // Wrapper to request a page of photos
    PhotoPage = Class();
    PhotoPage.prototype = {
        initialize: function(galleryKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.GalleryKey = galleryKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.PhotoPage = data;
        }
    };
    // Wrapper to request a page of videos
    VideoPage = Class();
    VideoPage.prototype = {
        initialize: function(galleryKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.GalleryKey = galleryKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.VideoPage = data;
        }
    };
    // Wrapper to request a comment action
    CommentAction = Class();
    CommentAction.prototype = {
        initialize: function(commentOnKey, onPageUrl, onPageTitle, commentBody, postedOnDate) {
            var data = new Object();
            data.CommentOnKey = commentOnKey;
            data.OnPageUrl = onPageUrl;
            data.OnPageTitle = onPageTitle;
            data.CommentBody = commentBody;
            data.PostedOnDate = postedOnDate;
            this.CommentAction = data;            
        }
    };
    // Wrapper to request a review action
    ReviewAction = Class();
    ReviewAction.prototype = {
        initialize: function(reviewOnThisKey, onPageUrl, onPageTitle,
                        reviewTitle, reviewRating, reviewBody, reviewPros, reviewCons) {
            var data = new Object();
            data.ReviewOnKey = reviewOnThisKey;
            data.OnPageUrl = onPageUrl;
            data.OnPageTitle = onPageTitle;
            data.ReviewTitle = reviewTitle;
            data.ReviewRating = reviewRating;
            data.ReviewBody = reviewBody;
            data.ReviewPros = reviewPros;
            data.ReviewCons = reviewCons;
            this.ReviewAction = data;
        }
    };
    // Wrapper to request a recommend action
    RecommendAction = Class();
    RecommendAction.prototype = {
        initialize: function(recommendThisKey, articleTitle) {
            var data = new Object();
            data.RecommendThisKey = recommendThisKey;
            if (articleTitle) {
                data.OnPageTitle = articleTitle;
            }

            this.RecommendAction = data;
        }
    };
    // Wrapper to request a rate action
    RateAction = Class();
    RateAction.prototype = {
        initialize: function(rateThisKey, rating, multiRate, ratingsReferenceKey) {
            var data = new Object();
            data.RateThisKey = rateThisKey;
            data.Rating = rating;
            if (typeof (multiRate) != "undefined") {
                data.MultiRate = multiRate;
            }
            if (typeof (ratingsReferenceKey) !== "undefined") {
                    data.RatingsReferenceKey = ratingsReferenceKey;
            }
            this.RateAction = data;
        }
    };

    // Permanently delete a gallery, video or photo
    DeleteContentAction = Class();
    DeleteContentAction.prototype = {
        initialize: function(deleteThisContent) {
            var data = new Object();
            data.DeleteThisContent = deleteThisContent;
            this.DeleteContentAction = data;
        }
    };

    // Email from the SiteLife system
    EmailContentAction = Class();
    EmailContentAction.prototype = {
        initialize: function(toAddress, subject, body) {
            var data = new Object();
            data.ToAddress = toAddress;
            data.Subject = subject;
            data.Body = body;
            this.EmailContentAction = data;
        }
    };

    // Email from the SiteLife system with user key as target
    EmailContentWithUserIDAction = Class();
    EmailContentWithUserIDAction.prototype = {
        initialize: function(toUserKey, subject, body) {
            var data = new Object();
            data.UserKey = toUserKey;
            data.Subject = subject;
            data.Body = body;
            this.EmailContentWithUserIDAction = data;
        }
    };

    // Wrapper to request a report abuse action
    ReportAbuseAction = Class();
    ReportAbuseAction.prototype = {
        initialize: function(reportThisKey, abuseReason, abuseDescription) {
            var data = new Object();
            data.ReportThisKey = reportThisKey;
            data.AbuseReason = abuseReason;
            data.AbuseDescription = abuseDescription;
            this.ReportAbuseAction = data;
        }
    };
    // Category used for discovery
    Category = Class();
    Category.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.Category = data;
        }
    };
    // Section used for discovery
    Section = Class();
    Section.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.Section = data;
        }
    };
    // Update or create an article
    UpdateArticleAction = Class();
    UpdateArticleAction.prototype = {
        initialize: function(updateArticle, onPageUrl, onPageTitle, section, categories) {
            var data = new Object();
            data.UpdateArticle = updateArticle;
            data.OnPageUrl = onPageUrl;
            data.OnPageTitle = onPageTitle;
            data.Section = section;
            data.Categories = categories;
            this.UpdateArticleAction = data;
        }
    };
    // Update or create a gallery
    UpdateGalleryAction = Class();
    UpdateGalleryAction.prototype = {
        initialize: function(updateGallery, galleryType, mediaType, title, description, tags, section, galleryPromo) {
            var data = new Object();
            data.UpdateGallery = updateGallery;
            data.GalleryType = galleryType;
            data.MediaType = mediaType;
            data.Title = title;
            data.Description = description;
            data.Tags = tags;
            data.Section = section;
            data.GalleryPromo = galleryPromo;
            this.UpdateGalleryAction = data;
        }
    };
    // Update or create a photo
    UpdatePhotoAction = Class();
    UpdatePhotoAction.prototype = {
        initialize: function(updatePhoto, title, description, tags, section) {
            var data = new Object();
            data.UpdatePhoto = updatePhoto;
            data.Title = title;
            data.Description = description;
            data.Tags = tags;
            data.Section = section;
            this.UpdatePhotoAction = data;
        }
    };
    // Update or create a video
    UpdateVideoAction = Class();
    UpdateVideoAction.prototype = {
        initialize: function(updateVideo, title, description, tags, section) {
            var data = new Object();
            data.UpdateVideo = updateVideo;
            data.Title = title;
            data.Description = description;
            data.Tags = tags;
            data.Section = section;
            this.UpdateVideoAction = data;
        }
    };
    // 
    GalleryType = Class();
    GalleryType.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.GalleryType = data;
        }
    };
    // GalleryPromo used for setting promotional text for public galleries
    GalleryPromo = Class();
    GalleryPromo.prototype = {
        initialize: function(title, body, photoKey) {
            var data = new Object();
            data.Title = title;
            data.Body = body;
            data.PhotoKey = photoKey;
            this.GalleryPromo = data;
        }
    };
    // UserTier used for discovery
    UserTier = Class();
    UserTier.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.UserTier = data;
        }
    };
    // MembershipTier used for community groups
    MembershipTier = Class();
    MembershipTier.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.MembershipTier = data;
        }
    };
    // Activity used for discovery
    Activity = Class();
    Activity.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.Activity = data;
        }
    };
    // Discovery on articles
    DiscoverArticlesAction = Class();
    DiscoverArticlesAction.prototype = {
        initialize: function(searchSections, searchCategories, limitToContributors, activity, age, maximumNumberOfDiscoveries) {
            var data = new Object();
            data.SearchSections = searchSections;
            data.SearchCategories = searchCategories;
            data.LimitToContributors = limitToContributors;
            data.Activity = activity;
            data.Age = age;
            data.MaximumNumberOfDiscoveries = maximumNumberOfDiscoveries;

            this.DiscoverArticlesAction = data;
        }
    };

    // Action used to add a friend
    AddFriendAction = Class();
    AddFriendAction.prototype = {
        initialize: function(friendUserKey) {
            var data = new Object();
            data.FriendUserKey = friendUserKey;
            this.AddFriendAction = data;
        }
    };

    // Action used to add a message
    AddPersonaMessageAction = Class();
    AddPersonaMessageAction.prototype = {
        initialize: function(toUserKey, body) {
            var data = new Object();
            data.ToUserKey = toUserKey;
            data.Body = body;
            this.AddPersonaMessageAction = data;
        }
    };

    // Action used to remove a message
    RemovePersonaMessageAction = Class();
    RemovePersonaMessageAction.prototype = {
        initialize: function(personaMessageKey) {
            var data = new Object();
            data.PersonaMessageKey = personaMessageKey;
            this.RemovePersonaMessageAction = data;
        }
    };

    // Action used to approve a friend
    ApproveFriendAction = Class();
    ApproveFriendAction.prototype = {
        initialize: function(friendUserKey, isApproved) {
            var data = new Object();
            data.FriendUserKey = friendUserKey;
            data.IsApproved = isApproved;
            this.ApproveFriendAction = data;
        }
    };

    // Action used to remove a friend
    RemoveFriendAction = Class();
    RemoveFriendAction.prototype = {
        initialize: function(friendUserKey) {
            var data = new Object();
            data.FriendUserKey = friendUserKey;
            this.RemoveFriendAction = data;
        }
    };

    // Action used to add an enemy
    AddEnemyAction = Class();
    AddEnemyAction.prototype = {
        initialize: function(enemyUserKey) {
            var data = new Object();
            data.EnemyUserKey = enemyUserKey;
            this.AddEnemyAction = data;
        }
    };

    // Action used to remove an enemy
    RemoveEnemyAction = Class();
    RemoveEnemyAction.prototype = {
        initialize: function(enemyUserKey) {
            var data = new Object();
            data.EnemyUserKey = enemyUserKey;
            this.RemoveEnemyAction = data;
        }
    };

    // Wrapper to request a friend page
    FriendPage = Class();
    FriendPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, isPendingList, filterKey, filterValue) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.IsPendingList = isPendingList;
            data.FilterKey = filterKey;
            data.FilterValue = filterValue;
            this.FriendPage = data;
        }
    };

    // Wrapper to request if a given user key is a friend of the user specified by the second parameter
    // if the userKey parameter is not specified, the currently logged-in user is used
    IsFriend = Class();
    IsFriend.prototype = {
        initialize: function(friendUserKey, userKey) {
            var data = new Object();
            data.FriendUserKey = friendUserKey;
            data.UserKey = userKey;
            this.IsFriend = data;
        }
    };

    // Wrapper to request a friend page
    EnemyPage = Class();
    EnemyPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.EnemyPage = data;
        }
    };

    // Discovery on content
    DiscoverContentAction = Class();
    DiscoverContentAction.prototype = {
        initialize: function(searchSections, searchCategories, limitToContributors, activity, contentType, age, maximumNumberOfDiscoveries, filterBySiteOfOrigin, parentKeys) {
            var data = new Object();
            data.SearchSections = searchSections;
            data.SearchCategories = searchCategories;
            data.LimitToContributors = limitToContributors;
            data.Activity = activity;
            data.ContentType = contentType;
            data.Age = age;
            data.MaximumNumberOfDiscoveries = maximumNumberOfDiscoveries;
            data.FilterBySiteOfOrigin = filterBySiteOfOrigin;
            if (parentKeys) {
                data.ParentKeys = parentKeys;
            }
            this.DiscoverContentAction = data;
        }
    };

    // Content type for discovery
    ContentType = Class();
    ContentType.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.ContentType = data;
        }
    };

    UpdateUserProfileAction = Class();
    UpdateUserProfileAction.prototype = {
        initialize: function(userKey,
                            aboutMe,
                            location,
                            signature,
                            dateOfBirth,
                            sex,
                            personaPrivacyMode,
                            commentsTabVisible,
                            photosTabVisible,
                            messagesOpenToEveryone,
                            isEmailNotificationsEnabled,
                            selectedStyleId,
                            customAnswers,
                            extendedProfile) {

            var data = new Object();
            data.UserKey = userKey;
            data.AboutMe = aboutMe;
            data.Location = location;
            data.Signature = signature;
            data.DateOfBirth = dateOfBirth;
            data.Sex = sex;
            data.PersonaPrivacyMode = personaPrivacyMode;
            data.CommentsTabVisible = commentsTabVisible;
            data.PhotosTabVisible = photosTabVisible;
            data.MessagesOpenToEveryone = messagesOpenToEveryone;
            data.IsEmailNotificationsEnabled = isEmailNotificationsEnabled;
            data.SelectedStyleId = selectedStyleId;
            data.CustomAnswers = customAnswers;
            data.ExtendedProfile = extendedProfile;
            this.UpdateUserProfileAction = data;
        }
    };

    UpdateUserBlockedSettingAction = Class();
    UpdateUserBlockedSettingAction.prototype = {
        initialize: function(userKey, isBlocked) {
            var data = new Object;
            data.UserKey = userKey;
            data.IsBlocked = isBlocked;
            this.UpdateUserBlockedSettingAction = data;
        }
    };

    SearchAction = Class();
    SearchAction.prototype = {
        initialize: function(searchType, searchString, numberPerPage, onPage) {
            var data = new Object();
            data.SearchType = searchType;
            data.SearchString = searchString;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.SearchAction = data;
        }
    };

    // Wrapper to request a watch item page
    WatchItemPage = Class();
    WatchItemPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.WatchItemPage = data;
        }
    };

    // Wrapper to add a watch item
    AddWatchItemAction = Class();
    AddWatchItemAction.prototype = {
        initialize: function(userKey, watchTargetKey, title, url) {
            var data = new Object();
            data.UserKey = userKey;
            data.WatchTargetKey = watchTargetKey;
            data.WatchItemTitle = title;
            data.WatchItemUrl = url;
            this.AddWatchItemAction = data;
        }
    };

    // Wrapper to delete a watch item
    DeleteWatchItemAction = Class();
    DeleteWatchItemAction.prototype = {
        initialize: function(userKey, watchTargetKey) {
            var data = new Object();
            data.UserKey = userKey;
            data.WatchTargetKey = watchTargetKey;
            this.DeleteWatchItemAction = data;
        }
    };

    // Wrapper to request a blog post page
    BlogPostPage = Class();
    BlogPostPage.prototype = {
        initialize: function(blogKey, numberPerPage, onPage, sort, blogPostState, restrictToOwner, includeFuturePosts) {
            var data = new Object();
            data.BlogKey = blogKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            data.BlogPostState = blogPostState;
            if ((typeof (restrictToOwner) == 'undefined') || (restrictToOwner == null)) {
                // Default to false for backwards compatibility
                restrictToOwner = false;
            }
            data.RestrictToOwner = restrictToOwner.toString();
            if ((typeof (includeFuturePosts) == 'undefined') || (includeFuturePosts == null)) {
                // Default to false for backwards compatibility
                includeFuturePosts = false;
            }
            data.IncludeFuturePosts = includeFuturePosts.toString();
            this.BlogPostPage = data;
        }
    };

    // Wrapper to request a blog post page by Tag
    BlogPostsByTagPage = Class();
    BlogPostsByTagPage.prototype = {
        initialize: function(blogKey, tag, numberPerPage, onPage, sort) {
            var data = new Object();
            data.BlogKey = blogKey;
            data.Tag = tag;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.BlogPostsByTagPage = data;
        }
    };


    // Wrapper to request a blog post archive count
    BlogPostArchiveCount = Class();
    BlogPostArchiveCount.prototype = {
        initialize: function(blogKey) {
            var data = new Object();
            data.BlogKey = blogKey;
            this.BlogPostArchiveCount = data;
        }
    };


    // Wrapper to request a blog post archive content page
    BlogPostArchiveContentPage = Class();
    BlogPostArchiveContentPage.prototype = {
        initialize: function(blogKey, month, numberPerPage, onPage, sort) {
            var data = new Object();
            data.BlogKey = blogKey;
            data.Month = month;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.BlogPostArchiveContentPage = data;
        }
    };


    // Wrapper to request a user comment page
    UserCommentPage = Class();
    UserCommentPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, sort, commentsOnly) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            data.CommentsOnly = commentsOnly;
            this.UserCommentPage = data;
        }
    };


    // Wrapper to request blog tag 
    RecentBlogTag = Class();
    RecentBlogTag.prototype = {
        initialize: function(blogKey) {
            var data = new Object();
            data.BlogKey = blogKey;
            this.RecentBlogTag = data;
        }
    };


    // Wrapper to request recent user photo page
    RecentUserPhotoPage = Class();
    RecentUserPhotoPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.RecentUserPhotoPage = data;
        }
    };

    // Wrapper to request recent user video page
    RecentUserVideoPage = Class();
    RecentUserVideoPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.RecentUserVideoPage = data;
        }
    };


    // Wrapper to request recent public gallery page
    RecentPublicGalleryPage = Class();
    RecentPublicGalleryPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.RecentPublicGalleryPage = data;
        }
    };


    // Wrapper to request recent user activity page
    RecentUserActivity = Class();
    RecentUserActivity.prototype = {
        initialize: function(userKey) {
            var data = new Object();
            data.UserKey = userKey;
            this.RecentUserActivity = data;
        }
    };


    // Wrapper to request page of user media submission counts
    UserMediaSubmissionsCountPage = Class();
    UserMediaSubmissionsCountPage.prototype = {
        initialize: function(userKey, mediaType, numberPerPage, onPage) {
            var data = new Object();
            data.UserKey = userKey;
            data.MediaType = mediaType;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.UserMediaSubmissionsCountPage = data;
        }
    };


    // Wrapper to request recent forum discussion page
    RecentForumDiscussionPage = Class();
    RecentForumDiscussionPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.RecentForumDiscussionPage = data;
        }
    };


    // Wrapper to request user group forum page
    UserGroupForumPage = Class();
    UserGroupForumPage.prototype = {
        initialize: function(userKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.UserKey = userKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.UserGroupForumPage = data;
        }
    };

    // Update or create a blog
    UpdateBlogAction = Class();
    UpdateBlogAction.prototype = {
        initialize: function(updateBlog, title, tagline, blogRollEntries, blogType, commentApproval) {
            var data = new Object();
            data.BlogKey = updateBlog;
            data.Title = title;
            data.Tagline = tagline;
            data.BlogRollEntries = blogRollEntries;
            data.BlogType = blogType;
            if ((typeof (commentApproval) == 'undefined' || (commentApproval == null))) {
                // Default to Everyone for backwards compatibility.
                commentApproval = "NoChange";
            }
            data.CommentApproval = commentApproval;
            this.UpdateBlogAction = data;
        }
    };

    // The blogRollEntry used in UpdateBlogAction
    BlogRollEntry = Class();
    BlogRollEntry.prototype = {
        initialize: function(name, url) {
            var data = new Object();
            data.Name = name;
            data.Url = url;
            this.BlogRollEntry = data;
        }
    };

    // Bookmark used in UpdateCommunityGroupAction
    Bookmark = Class();
    Bookmark.prototype = {
        initialize: function(title, link) {
            var data = new Object();
            data.Title = title;
            data.Link = link;
            this.Bookmark = data;
        }
    };

    // CommunityGroupVisibility used in UpdateCommunityGroupAction
    CommunityGroupVisibility = Class();
    CommunityGroupVisibility.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.CommunityGroupVisibility = data;
        }
    };

    // Update or create a blog post, key can be either a post key (update case)
    // or a blog key (create case)
    UpdateBlogPostAction = Class();
    UpdateBlogPostAction.prototype = {
        initialize: function(key, title, body, tags, publishDate, published) {
            var data = new Object();
            data.TargetThis = key;
            data.Title = title;
            data.Body = body;
            data.Tags = tags;
            data.Date = publishDate;
            data.Published = published;
            this.UpdateBlogPostAction = data;
        }
    };

    // Identify a forum discussion with this DiscussionKey 
    DiscussionKey = Class();
    DiscussionKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.DiscussionKey = data;
        }
    };

    // Identify a custom item with this CustomItemKey
    CustomItemKey = Class();
    CustomItemKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.CustomItemKey = data;
        }
    };

    // Identify a custom collection with this CustomCollectionKey
    CustomCollectionKey = Class();
    CustomCollectionKey.prototype = {
        initialize: function(key) {
            var data = new Object();
            data.Key = key;
            this.CustomCollectionKey = data;
        }
    };

    // Update or create a custom item in storage
    UpdateCustomItemAction = Class();
    UpdateCustomItemAction.prototype = {
        initialize: function(customItemKey, name, mimeType, displayText, content, includeInRecentActivity) {
            var data = new Object();
            data.CustomItemKey = customItemKey;
            data.Name = name;
            data.MimeType = mimeType;
            data.DisplayText = displayText;
            data.Content = content;
            if ((typeof (includeInRecentActivity) == 'undefined') || (includeInRecentActivity == null)) {
                // Default to true for backwards compatibility
                includeInRecentActivity = true;
            }
            data.IncludeInRecentActivity = includeInRecentActivity
            this.UpdateCustomItemAction = data;
        }
    };

    // Add a new custom collection to storage
    AddCustomCollectionAction = Class();
    AddCustomCollectionAction.prototype = {
        initialize: function(customCollectionKey, customCollectionName) {
            var data = new Object();
            data.CustomCollectionKey = customCollectionKey;
            data.CustomCollectionName = customCollectionName;
            this.AddCustomCollectionAction = data;
        }
    };

    // Insert an item into a custom collection
    InsertIntoCollectionAction = Class();
    InsertIntoCollectionAction.prototype = {
        initialize: function(customCollectionKey, insertThisKey, position) {
            var data = new Object();
            data.CustomCollectionKey = customCollectionKey;
            data.InsertThisKey = insertThisKey;
            data.Position = position;
            this.InsertIntoCollectionAction = data;
        }
    };

    // Remove an item from a custom collection (position can be null to specify to remove all occurrences of item)
    RemoveFromCollectionAction = Class();
    RemoveFromCollectionAction.prototype = {
        initialize: function(customCollectionKey, removeThisKey, position) {
            var data = new Object();
            data.CustomCollectionKey = customCollectionKey;
            data.RemoveThisKey = removeThisKey;
            data.Position = position;
            this.RemoveFromCollectionAction = data;
        }
    };

    // Get a page of items out of a custom collection
    CustomCollectionPage = Class();
    CustomCollectionPage.prototype = {
        initialize: function(customCollectionKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.CustomCollectionKey = customCollectionKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.CustomCollectionPage = data;
        }
    };


    // Get a page of items out of a custom collection
    EditorMessageRequest = Class();
    EditorMessageRequest.prototype = {
        initialize: function() {
            this.EditorMessageRequest = new Object();
        }
    };

    // Retrieve a user's tags for the given content type
    UserTags = Class();
    UserTags.prototype = {
        initialize: function(userKey, contentType) {
            var data = new Object();
            data.UserKey = userKey;
            data.ContentType = contentType;
            this.UserTags = data;
        }
    };


    // Get an item's ContentPolicy
    GetContentPolicyAction = Class();
    GetContentPolicyAction.prototype = {
        initialize: function(targetKey, userTier, action) {
            var data = new Object();
            data.TargetKey = targetKey;
            data.UserTier = userTier;
            data.ContentPolicyActionType = action;
            this.GetContentPolicyAction = data;
        }
    }

    // Set an item's ContentPolicy
    SetContentPolicyAction = Class();
    SetContentPolicyAction.prototype = {
        initialize: function(targetKey, userTier, action, policy) {
            var data = new Object();
            data.TargetKey = targetKey;
            data.UserTier = userTier;
            data.ContentPolicyActionType = action;
            data.ContentPolicy = policy;
            this.SetContentPolicyAction = data;
        }
    }

    ContentPolicy = Class();
    ContentPolicy.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.ContentPolicy = data;
        }
    };

    ContentPolicyActionType = Class();
    ContentPolicyActionType.prototype = {
        initialize: function(name) {
            var data = new Object();
            data.Name = name;
            this.ContentPolicyActionType = data;
        }
    };

    // Updates a Forum's meta data
    UpdateForumAction = Class();
    UpdateForumAction.prototype = {
        initialize: function(forumKey, title, description) {
            var data = new Object();
            data.ForumKey = forumKey;
            data.Title = title;
            data.Description = description;
            this.UpdateForumAction = data;
        }
    };

    //Adds/Updates a Forum Discussion's meta data. If the key is a ForumKey, it will be added as a new Discussion.
    //If the key is a ForumDiscussionKey, the existing forum discussion will be updated.
    UpdateForumDiscussionAction = Class();
    UpdateForumDiscussionAction.prototype = {
        initialize: function(key, title, body, isQuestion, isPoll, section, categories) {
            var data = new Object();
            data.TargetThis = key;
            data.Title = title;
            data.Body = body;
            data.IsQuestion = typeof (isQuestion) == 'string' ? isQuestion : (isQuestion ? "true" : "false");
            data.IsPoll = typeof (isPoll) == 'string' ? isPoll : (isPoll ? "true" : "false");
            if (typeof (section) != "undefined") {
                data.Section = section;
            }
            if (typeof (categories) != "undefined") {
                data.Categories = categories;
            }
            this.UpdateForumDiscussionAction = data;
        }
    };

    //Adds/Updates a Forum Post's meta data. If the key is a ForumDiscussionKey, it will be added as a new Post.
    //If the key is a ForumPostKey, the existing forum post will be updated.
    UpdateForumPostAction = Class();
    UpdateForumPostAction.prototype = {
        initialize: function(key, title, body, isQuestion) {
            var data = new Object();
            data.TargetThis = key;
            data.Title = title;
            data.Body = body;
            data.IsQuestion = isQuestion;
            this.UpdateForumPostAction = data;
        }
    };

    //Updates a Forum Discussion's Sticky flag
    ForumToggleDiscussionStickyAction = Class();
    ForumToggleDiscussionStickyAction.prototype = {
        initialize: function(discussionKey) {
            var data = new Object();
            data.DiscussionKey = discussionKey;
            this.ForumToggleDiscussionStickyAction = data;
        }
    };

    //Opens/Closes a Forum Discussion
    ForumToggleDiscussionClosedAction = Class();
    ForumToggleDiscussionClosedAction.prototype = {
        initialize: function(discussionKey) {
            var data = new Object();
            data.DiscussionKey = discussionKey;
            this.ForumToggleDiscussionClosedAction = data;
        }
    };

    //Retrieves a paginated list of Discussions for a particular Forum
    ForumDiscussionsPage = Class();
    ForumDiscussionsPage.prototype = {
        initialize: function(forumKey, numberPerPage, oneBasedOnPage, sort) {
            var data = new Object();
            data.ForumKey = forumKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            this.ForumDiscussionsPage = data;
        }
    };

    //Retrieves a paginated list of Posts for a particular Forum
    ForumPostsPage = Class();
    ForumPostsPage.prototype = {
        initialize: function(forumDiscussionKey, numberPerPage, oneBasedOnPage, sort, findPostKey) {
            var data = new Object();
            data.DiscussionKey = forumDiscussionKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            data.FindPostKey = findPostKey;
            this.ForumPostsPage = data;
        }
    };

    //Retrieves a paginated list of forums for a particular category
    ForumCategoriesPage = Class();
    ForumCategoriesPage.prototype = {
        initialize: function(numberPerPage, oneBasedOnPage) {
            var data = new Object();
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            this.ForumCategoriesPage = data;
        }
    };

    //Retrieves a paginated list of forums for a particular category
    ForumsPage = Class();
    ForumsPage.prototype = {
        initialize: function(categoryKey, numberPerPage, oneBasedOnPage, sort) {
            var data = new Object();
            data.ForumCategoryKey = categoryKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            this.ForumsPage = data;
        }
    };

    ForumSearchAction = Class();
    ForumSearchAction.prototype = {
        initialize: function(searchKey, searchString, numberPerPage, onPage) {
            var data = new Object();
            data.TargetThis = searchKey;
            data.SearchString = searchString;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.ForumSearchAction = data;
        }
    };

    // Retrieves a paginated list of community groups
    CommunityGroupPage = Class();
    CommunityGroupPage.prototype = {
        initialize: function(numberPerPage, oneBasedOnPage, sort, section) {
            var data = new Object();
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            if ((typeof (section) == 'undefined') || (section == null)) {
                // Default section to All
                section = new Section("All");
            }
            data.Section = section;
            this.CommunityGroupPage = data;
        }
    };

    // Retrieves a paginated list of community groups
    CommunityGroupMembership = Class();
    CommunityGroupMembership.prototype = {
        initialize: function(groupKey, userKey) {
            var data = new Object();
            data.CommunityGroupKey = groupKey;
            data.UserKey = userKey;
            this.CommunityGroupMembership = data;
        }
    };


    // Retrieves a paginated list of community groups
    CommunityGroupMembershipPage = Class();
    CommunityGroupMembershipPage.prototype = {
        initialize: function(key, numberPerPage, oneBasedOnPage, sort, membershipFilter) {
            var data = new Object();
            data.Key = key;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            data.MembershipFilter = membershipFilter;
            this.CommunityGroupMembershipPage = data;
        }
    };

    // Retrieves a paginated list of registrants
    CommunityGroupRegistrantPage = Class();
    CommunityGroupRegistrantPage.prototype = {
        initialize: function(key, numberPerPage, oneBasedOnPage, sort) {
            var data = new Object();
            data.CommunityGroupKey = key;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            this.CommunityGroupRegistrantPage = data;
        }
    };

    // Retrieves a paginated list of banned users
    CommunityGroupBannedUserPage = Class();
    CommunityGroupBannedUserPage.prototype = {
        initialize: function(key, numberPerPage, oneBasedOnPage, sort) {
            var data = new Object();
            data.CommunityGroupKey = key;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            this.CommunityGroupBannedUserPage = data;
        }
    };

    // Retrieves a paginated list of invited users
    CommunityGroupInvitedUserPage = Class();
    CommunityGroupInvitedUserPage.prototype = {
        initialize: function(key, numberPerPage, oneBasedOnPage, sort) {
            var data = new Object();
            data.CommunityGroupKey = key;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            this.CommunityGroupInvitedUserPage = data;
        }
    };



    // Creates a new or updates an existing community group
    UpdateCommunityGroupAction = Class();
    UpdateCommunityGroupAction.prototype = {
        initialize: function(key, title, description, categories, visibility, bookmarks, section, photoKey) {
            var data = new Object();
            data.CommunityGroupKey = key;
            data.Title = title;
            data.Description = description;
            data.Categories = categories;
            data.Visibility = visibility,
        data.Bookmarks = bookmarks;
            data.Section = section;
            data.PhotoKey = photoKey;
            this.UpdateCommunityGroupAction = data;
        }
    };

    // Updates an existing commnity group's bookmarks
    UpdateCommunityGroupBookmarksAction = Class();
    UpdateCommunityGroupBookmarksAction.prototype = {
        initialize: function(key, bookmarks) {
            var data = new Object();
            data.CommunityGroupKey = key;
            data.Bookmarks = bookmarks;
            this.UpdateCommunityGroupBookmarksAction = data;
        }
    };

    // Creates or updates a user's membership in a group, with options to ban the user from the group.
    UpdateCommunityGroupMembershipAction = Class();
    UpdateCommunityGroupMembershipAction.prototype = {
        initialize: function(communityGroupKey, userKey, membershipTier, isBanned, banMessage) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.UserKey = userKey;
            data.MembershipTier = membershipTier;
            data.IsBanned = isBanned;
            data.BanMessage = banMessage;
            this.UpdateCommunityGroupMembershipAction = data;
        }
    };

    // Enables a user to request membership in a community group or an admin to invite a non-member.
    RequestCommunityGroupMembershipAction = Class();
    RequestCommunityGroupMembershipAction.prototype = {
        initialize: function(communityGroupKey, userKey, message) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.UserKey = userKey;
            data.Message = message;
            this.RequestCommunityGroupMembershipAction = data;
        }
    };
    
    // allows a manager or admin to send a mass message to members of the group
    CommunityGroupSendGroupMessageAction = Class();
    CommunityGroupSendGroupMessageAction.prototype = {
        initialize: function(communityGroupKey, subject, body){
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;  
            data.Subject = subject;
            data.Body = body;
            this.CommunityGroupSendGroupMessageAction = data;
        }
    };


    // allows a users preferences for a specific community group to be created or updated
    UpdateCommunityGroupUserPrefsAction = Class();
    UpdateCommunityGroupUserPrefsAction.prototype = {
        initialize: function(communityGroupKey, userKey, enableGroupDigestMessages, enableGroupManagerMessages, preferredForumPostSortOrder){
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;  
            data.UserKey = userKey;
            data.EnableGroupDigestMessages = enableGroupDigestMessages;
            data.EnableGroupManagerMessages = enableGroupManagerMessages;
            data.PreferredForumPostSortOrder = preferredForumPostSortOrder;
            this.UpdateCommunityGroupUserPrefsAction = data;
        }
    };


    // retrieves a users's preferences for a specific community group
    CommunityGroupUserPrefs = Class();
    CommunityGroupUserPrefs.prototype = {
        initialize: function(communityGroupKey, userKey){
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;  
            data.UserKey = userKey;
            this.CommunityGroupUserPrefs = data;
        }
    };


    //Retrieves a paginated list of Events for a particular EventSetKey
    EventsPage = Class();
    EventsPage.prototype = {
        initialize: function(eventSetKey, startDate, endDate, numberPerPage, oneBasedOnPage, sort) {
            var data = new Object();
            data.EventSetKey = eventSetKey;
            data.StartDate = startDate;
            data.EndDate = endDate;
            data.NumberPerPage = numberPerPage;
            data.OnPage = oneBasedOnPage;
            data.Sort = sort;
            this.EventsPage = data;
        }
    };

    // Update or creates an Event, key can be either an EventKey (update case)
    // or an EventSetKey (create case)
    UpdateEventAction = Class();
    UpdateEventAction.prototype = {
        initialize: function(key, title, description, location, bookmarkName, bookmarkUrl, startDate, endDate, utcOffset) {
            var data = new Object();
            data.TargetThis = key;
            data.Title = title;
            data.Description = description;
            data.Location = location;
            data.BookmarkName = bookmarkName;
            data.BookmarkUrl = bookmarkUrl;
            data.StartDate = startDate;
            data.EndDate = endDate;
            data.UtcOffset = utcOffset;
            this.UpdateEventAction = data;
        }
    };


    // Retrieve a paginated list of recent group activities
    RecentMiniFeedActivity = Class();
    RecentMiniFeedActivity.prototype = {
        initialize: function(communityGroupKey, onPage, numberPerPage) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.OnPage = onPage;
            data.NumberPerPage = numberPerPage
            this.RecentMiniFeedActivity = data;
        }
    }

    //Retrieve a list of Most Active Users in a CommunityGroup
    CommunityGroupMostActiveMembers = Class();
    CommunityGroupMostActiveMembers.prototype = {
        initialize: function(communityGroupKey, age, maximumNumberOfMembers) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.Age = age;
            data.MaximumNumberOfMembers = maximumNumberOfMembers
            this.CommunityGroupMostActiveMembers = data;
        }
    }

    // perform a search for content within a specific community group
    CommunityGroupSearchAction = Class();
    CommunityGroupSearchAction.prototype = {
        initialize: function(communityGroupKey, searchType, searchString, numberPerPage, onPage) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.SearchType = searchType;
            data.SearchString = searchString;
            data.OnPage = onPage;
            data.NumberPerPage = numberPerPage;
            this.CommunityGroupSearchAction = data;
        }
    }

    // perform a search for content within a specific community group
    RequestDeleteCommunityGroupAction = Class();
    RequestDeleteCommunityGroupAction.prototype = {
        initialize: function(communityGroupKey, deleteReason) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.DeleteReason = deleteReason;
            this.RequestDeleteCommunityGroupAction = data;
        }
    }

    CommunityGroupRecentForumDiscussions = Class();
    CommunityGroupRecentForumDiscussions.prototype = {
        initialize: function(communityGroupKey, age, maximumNumberOfDiscussions) {
            var data = new Object();
            data.CommunityGroupKey = communityGroupKey;
            data.Age = age;
            data.MaximumNumberOfDiscussions = maximumNumberOfDiscussions;
            this.CommunityGroupRecentForumDiscussions = data;
        }
    }


    SystemTimeInfo = Class();
    SystemTimeInfo.prototype = {
        initialize: function() {
            var data = new Object();
            this.SystemTimeInfo = data;
        }
    }

    PrivateMessageFolderList = Class();
    PrivateMessageFolderList.prototype = {
        initialize: function() {
            var data = new Object();
            this.PrivateMessageFolderList = data;
        }
    }


    PrivateMessage = Class();
    PrivateMessage.prototype = {
        initialize: function(folderID, messageID) {
            var data = new Object();
            data.FolderID = folderID;
            data.MessageID = messageID;
            this.PrivateMessage = data;
        }
    }

    PrivateMessagePage = Class();
    PrivateMessagePage.prototype = {
        initialize: function(folderID, numberPerPage, onPage, messageReadState) {
            var data = new Object();
            data.FolderID = folderID;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.MessageReadState = messageReadState;
            this.PrivateMessagePage = data;
        }
    }

    PrivateMessageSendAction = Class();
    PrivateMessageSendAction.prototype = {
        initialize: function(subject, body, recipientList) {
            var data = new Object();
            data.Subject = subject;
            data.Body = body;
            data.RecipientList = recipientList;
            this.PrivateMessageSendAction = data;
        }
    }

    PrivateMessageMoveMessageAction = Class();
    PrivateMessageMoveMessageAction.prototype = {
        initialize: function(sourceFolderID, destinationFolderID, messageIDList) {
            var data = new Object();
            data.SourceFolderID = sourceFolderID;
            data.DestinationFolderID = destinationFolderID;
            data.MessageIDList = messageIDList;
            this.PrivateMessageMoveMessageAction = data;
        }
    }

    PrivateMessageDeleteMessageAction = Class();
    PrivateMessageDeleteMessageAction.prototype = {
        initialize: function(sourceFolderID, messageIDList) {
            var data = new Object();
            data.SourceFolderID = sourceFolderID;
            data.MessageIDList = messageIDList;
            this.PrivateMessageDeleteMessageAction = data;
        }
    }

    PrivateMessageEmptyTrashAction = Class();
    PrivateMessageEmptyTrashAction.prototype = {
        initialize: function() {
            var data = new Object();
            this.PrivateMessageEmptyTrashAction = data;
        }
    }


    PrivateMessageCreateFolderAction = Class();
    PrivateMessageCreateFolderAction.prototype = {
        initialize: function() {
            var data = new Object();
            data.FolderID = "Inbox";
            this.PrivateMessageCreateFolderAction = data;
        }
    }

    FirstUnreadPost = Class();
    FirstUnreadPost.prototype = {
        initialize: function(discussionKey, numberPerPage, sort) {
            var data = new Object();
            data.DiscussionKey = discussionKey;
            data.NumberPerPage = numberPerPage;
            data.Sort = sort;
            this.FirstUnreadPost = data;
        }
    }

    LatestPost = Class();
    LatestPost.prototype = {
        initialize: function(discussionKey, numberPerPage, sort) {
            var data = new Object();
            data.DiscussionKey = discussionKey;
            data.NumberPerPage = numberPerPage;
            data.Sort = sort;
            this.LatestPost = data;
        }
    }

    UpdateDiscussionLastReadAction = Class();
    UpdateDiscussionLastReadAction.prototype = {
        initialize: function(discussionKey, postKey, forceUpdate) {
            var data = new Object();
            data.DiscussionKey = discussionKey;
            if (postKey) {
                data.ForumPostKey = postKey;
            }
            if (forceUpdate) {
                data.ForceUpdate = true;
            }
            else {
                data.ForceUpdate = false;
            }
            this.UpdateDiscussionLastReadAction = data;
        }
    }

    UpdateForumAllReadAction = Class();
    UpdateForumAllReadAction.prototype = {
        initialize: function(forumKey) {
            var data = new Object();
            data.ForumKey = forumKey;
            this.UpdateForumAllReadAction = data;
        }
    }

    UpdateCategoryAllReadAction = Class();
    UpdateCategoryAllReadAction.prototype = {
        initialize: function(categoryKey) {
            var data = new Object();
            data.ForumCategoryKey = categoryKey;
            this.UpdateCategoryAllReadAction = data;
        }
    }

    UpdateExternalUserIdAction = Class();
    UpdateExternalUserIdAction.prototype = {
        initialize: function(externalSiteName, externalSiteUserId, forUser) {
            var data = new Object();
            data.ExternalSiteName = externalSiteName;
            data.ExternalSiteUserId = externalSiteUserId;
            data.ForUser = forUser;
            this.UpdateExternalUserIdAction = data;
        }
    }

    UpdateSubscriptionAction = Class();
    UpdateSubscriptionAction.prototype = {
        initialize: function(key, subscribe) {
            var data = new Object();
            data.SubscribeTo = key;
            data.Subscribe = subscribe;
            this.UpdateSubscriptionAction = data;
        }
    }

    UpdatePollAction = Class();
    UpdatePollAction.prototype = {
        initialize: function(pollOnKey, question, answers) {
            var data = new Object();
            data.PollOnKey = pollOnKey;
            data.Question = question;
            data.Answers = answers;
            this.UpdatePollAction = data;
        }
    }

    TogglePollIsClosedAction = Class();
    TogglePollIsClosedAction.prototype = {
        initialize: function(pollKey) {
            var data = new Object();
            data.ToggleThisPoll = pollKey;
            this.TogglePollIsClosedAction = data;
        }
    }

    PostPollAnswerAction = Class();
    PostPollAnswerAction.prototype = {
        initialize: function(pollToAnswer, indexOfAnswer) {
            var data = new Object();
            data.PollToAnswer = pollToAnswer;
            data.IndexOfAnswer = indexOfAnswer;
            this.PostPollAnswerAction = data;
        }
    }

    PollPage = Class();
    PollPage.prototype = {
        initialize: function(pollOnKey, numberPerPage, onPage, sort) {
            var data = new Object();
            data.PollOnKey = pollOnKey;
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Sort = sort;
            this.PollPage = data;
        }
    }

    CheckFilteredWords = Class();
    CheckFilteredWords.prototype = {
        initialize: function(keyValueDictionary) { // key is the string ID, value is the string to be checked - formatted like { "key1":"string1", "key2":"string2" }.
            var data = new Object();
            data.WordDictionary = keyValueDictionary;
            this.CheckFilteredWords = data;
        }
    }

    //Points&Badging
    AwardPointsAction = Class();
    AwardPointsAction.prototype = {
        initialize: function(userKey, points, currencyType) {
            var data = new Object();
            data.UserKey = userKey;
            data.Points = points;
            data.CurrencyType = currencyType;
            this.AwardPointsAction = data;
        }
    }

    BadgeFamily = Class();
    BadgeFamily.prototype = {
        initialize: function(badgeFamilyKey) {
            var data = new Object();
            data.BadgeFamilyKey = badgeFamilyKey;
            this.BadgeFamily = data;
        }
    }

    BadgeFamilies = Class();
    BadgeFamilies.prototype = {
        initialize: function() {
            var data = new Object();
            this.BadgeFamilies = data;
        }
    }

    BadgingEventAction = Class();
    BadgingEventAction.prototype = {
        initialize: function(activityName, activityTags, userTags) {
            var data = new Object();
            data.ActivityName = activityName;
            data.ActivityTags = activityTags
            data.UserTags = userTags;
            this.BadgingEventAction = data;
        }
    }

    GrantBadgeAction = Class();
    GrantBadgeAction.prototype = {
        initialize: function(userKey, badgeFamilyKey, badgeKey) {
            var data = new Object();
            data.UserKey = userKey;
            data.BadgeFamilyKey = badgeFamilyKey
            data.BadgeKey = badgeKey;
            this.GrantBadgeAction = data;
        }
    }

    Leaderboard = Class();
    Leaderboard.prototype = {
        initialize: function(leaderboardKey) {
            var data = new Object();
            data.LeaderboardKey = leaderboardKey;
            this.Leaderboard = data;
        }
    }

    Leaderboards = Class();
    Leaderboards.prototype = {
        initialize: function() {
            var data = new Object();
            this.Leaderboards = data;
        }
    }

    LeaderboardRankingsPage = Class();
    LeaderboardRankingsPage.prototype = {
        initialize: function(leaderboardKey, oneBasedOnPage) {
            var data = new Object();
            data.LeaderboardKey = leaderboardKey;
            data.OnPage = oneBasedOnPage;
            this.LeaderboardRankingsPage = data;
        }
    }

    RevokeBadgeAction = Class();
    RevokeBadgeAction.prototype = {
        initialize: function(userKey, badgeFamilyKey, badgeKey) {
            var data = new Object();
            data.UserKey = userKey;
            data.BadgeFamilyKey = badgeFamilyKey
            data.BadgeKey = badgeKey;
            this.RevokeBadgeAction = data;
        }
    }

    PointsAndBadgingRuleValidationAction = Class();
    PointsAndBadgingRuleValidationAction.prototype = {
        initialize: function(rules) {
            var data = new Object();
            data.Rules = rules;
            this.PointsAndBadgingRuleValidationAction = data;
        }
    }

    AbuseItemPage = Class();
    AbuseItemPage.prototype = {
        initialize: function(numberPerPage, onPage, section, maxReportsPerItem) {
            var data = new Object();
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            data.Section = section;
            data.MaxReportsPerItem = maxReportsPerItem;
            this.AbuseItemPage = data;
        }
    }

    AbuseItem = Class();
    AbuseItem.prototype = {
        initialize: function(targetKey) {
            var data = new Object();
            data.TargetKey = targetKey;
            this.AbuseItem = data;
        }
    }

    ClearAbuseAction = Class();
    ClearAbuseAction.prototype = {
        initialize: function(targetKey) {
            var data = new Object();
            data.TargetKey = targetKey;
            this.ClearAbuseAction = data;
        }
    }

    SetCommentBlockingStateAction = Class();
    SetCommentBlockingStateAction.prototype = {
        initialize: function(commentKey, blockingState) {
            var data = new Object();
            data.CommentKey = commentKey;
            data.CommentBlockingState = blockingState;
            this.SetCommentBlockingStateAction = data;
        }
    }
    //Community feed
    CommunityFeedRequest = Class();
    CommunityFeedRequest.prototype = {
        initialize: function(activityForTypes, count) {
            var data = new Object();
            data.ActivityForTypes = activityForTypes;
            data.Count = count;
            this.CommunityFeedRequest = data;
        }
    }

    // updates the flag on individual content as to
    // whether or not the content will be included in
    // discovery results
    UpdateDiscoveryFilterFlagOnContentAction = Class();
    UpdateDiscoveryFilterFlagOnContentAction.prototype = {
        initialize: function(content, excludeContentFlag, siteList) {
            var data = new Object();
            data.DiscoveryFilterFlagExcludeThisContent = content;
            data.ExcludeContentFlag = excludeContentFlag;
            data.SiteList = siteList;
            this.UpdateDiscoveryFilterFlagOnContentAction = data;
        }
    };

    SendTwitterMessageAction = Class();
    SendTwitterMessageAction.prototype = {
        initialize: function(message, url, template) {
            var data = new Object();
            data.Message = message;
            data.Url = url;
            data.Template = template;
            this.SendTwitterMessageAction = data;
        }
    }

    UserTwitterStatus = Class();
    UserTwitterStatus.prototype = {
        initialize: function(userKey) {
            var data = new Object();
            data.UserKey = userKey;
            this.UserTwitterStatus = data;
        }
    }


    UserTwitterFriends = Class();
    UserTwitterFriends.prototype = {
        initialize: function(numberPerPage, onPage) {
            var data = new Object();
            data.NumberPerPage = numberPerPage;
            data.OnPage = onPage;
            this.UserTwitterFriends = data;
        }
    }

    UserExtendedPrefs = Class();
    UserExtendedPrefs.prototype = {
        initialize: function(userKey) {
            var data = new Object();
            data.UserKey = userKey;
            this.UserExtendedPrefs = data;
    	}
    }
    FriendFeedRequest = Class();
    FriendFeedRequest.prototype = {
        initialize: function(forUserKey, pageNumber, includeTypes) {
            var data = new Object();
            data.ForUserKey = forUserKey;
            data.PageNumber = pageNumber;
            data.IncludeTypes = includeTypes;
            this.FriendFeedRequest = data;
        }
    }
    
    AddFriendFeedReactionRequest = Class();
    AddFriendFeedReactionRequest.prototype = {
        initialize: function(reactionOnKey, authorUserKey, body) {
            var data = new Object();
            data.ReactionOnKey = reactionOnKey;
            data.AuthorKey = authorUserKey;
            data.Body = body;
            this.AddFriendFeedReactionRequest = data;
	}
    }
    
    UpdateUserExtendedPrefAction = Class();
    UpdateUserExtendedPrefAction.prototype = {
        initialize: function(name, value) {
            var data = new Object();
            data.PrefName = name;
            data.PrefValue = value;
            this.UpdateUserExtendedPrefAction = data;
        }
    }
    
    UpdateUserPathRequest = Class();
    UpdateUserPathRequest.prototype = {
        initialize: function(userKey, path){
            var data = new Object();
            data.User = userKey;
            data.Path = path;
            this.UpdateUserPathRequest = data;
	}
    }
    
    DeleteFriendFeedReactionRequest = Class();
    DeleteFriendFeedReactionRequest.prototype = {
        initialize: function(onFeedActivityKey, reactionKey) {
            var data = new Object();
            data.ReactionOnKey = onFeedActivityKey;
            data.ReactionKey = reactionKey;
            this.DeleteFriendFeedReactionRequest = data;
        }
    }
    
    UsersForPathRequest = Class();
    UsersForPathRequest.prototype = {
        initialize: function(forPath, includeSubPaths){
            var data = new Object();
            data.Path = forPath;
            data.IncludeSubPaths = includeSubPaths;
            this.UsersForPathRequest = data;
	}
    }
    
    SetFriendFeedUserVisibilityRequest = Class();
    SetFriendFeedUserVisibilityRequest.prototype = {
        initialize: function(feedOwner, forUser, isVisible){
            var data = new Object();
            data.FeedOwnerUserKey = feedOwner;
            data.ForUserKey = forUser;
            data.Visible = isVisible;
            this.SetFriendFeedUserVisibilityRequest = data;
        }
    }
    
    HiddenFriendFeedUsersRequest = Class();
    HiddenFriendFeedUsersRequest.prototype = {
        initialize: function(forUserKey){
            var data = new Object();
            data.ForUserKey = forUserKey;
            this.HiddenFriendFeedUsersRequest = data;
	}
    }
    
    PathForUserRequest = Class();
    PathForUserRequest.prototype = {
        initialize: function(forUserKey){
            var data = Object();
            data.User = forUserKey;
            this.PathForUserRequest = data;
        }
    }
	CommentRequest = Class();
	CommentRequest.prototype = {
		initialize: function(commentKey, lookInModeration) {
			var data = Object();
			data.CommentKey = commentKey;
			data.LookInModeration = lookInModeration;
			this.CommentRequest = data;
		}
	}
    
    SendYahooUpdateMessageAction = Class();
    SendYahooUpdateMessageAction.prototype = {
        initialize: function(message, url, template) {
            var data = new Object();
            data.Message = message;
            data.Url = url;
            data.Template = template;
            this.SendYahooUpdateMessageAction = data;
        }
    }
    
    SendLinkedInUpdateMessageAction = Class();
    SendLinkedInUpdateMessageAction.prototype = {
		initialize: function(message, url, template) {
			var data = new Object();
			data.Message = message;
			data.Url = url;
			data.Template = template;
			this.SendLinkedInUpdateMessageAction = data;
		}
    }
    
    SendLinkedInNetworkUpdateMessageAction = Class();
    SendLinkedInNetworkUpdateMessageAction.prototype = {
		initialize: function(message, url, template) {
			var data = new Object();
			data.Message = message;
			data.Url = url;
			data.Template = template;
			this.SendLinkedInNetworkUpdateMessageAction = data;
		}
    }
    
    UserLinkedInProfile = Class();
    UserLinkedInProfile.prototype = {
        initialize: function(userKey) {
            var data = new Object();
            data.UserKey = userKey;
            this.UserLinkedInProfile = data;
        }
    }
    
    UserLinkedInUniqueId = Class();
    UserLinkedInUniqueId.prototype = {
		initialize: function(userKey) {
			var data = new Object();
			data.UserKey = userKey;
			this.UserLinkedInUniqueId = data;
		}
    }
    
    ForumViewTrackingAction = Class();
    ForumViewTrackingAction.prototype = {
		initialize: function(discussionKey) {
			var data = new Object();
			data.DiscussionKey = discussionKey;
			this.ForumViewTrackingAction = data;
		}
    }

})();
// Copyright � Pluck Corporation 2008. This software code and related intellectual property are the 
// property of Pluck Corporation and are licensed for use solely on designated websites. Any distribution, 
// copying, or other use of this intellectual property other than pursuant to a written agreement 
// with Pluck Corporation is strictly prohibited. All Rights Reserved.
//

//
//  !!!    NOTE:  This file is used by both GROUPS and POD .. do not edit this file unless you have coordinated as such  !!!
//



(function(){
  if (typeof dmgroups === 'undefined') {
    dmgroups = {
      extend: function(source){
        for (var _var in source) {
          this[_var] = source[_var];
        }
      }
    }
  };
  
  if (typeof dmgroups.serviceFramework === 'undefined') {
    dmgroups.serviceFramework = 1;
    var DAAPIServiceDetails = {
      getHost: function() { return PLUCKSL_GLOBAL_OPTIONS.siteLifeHost; },
      getServerUrl: function(apiKey,authToken) { return PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl + PLUCKSL_GLOBAL_OPTIONS.daapiSuffix; },
      getFlashTunnelUrl: function(apiKey) { return PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl + PLUCKSL_GLOBAL_OPTIONS.flashTunnelUrlSuffix; },
      getFlashExpressInstallUrl: function(apiKey) { return PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl + PLUCKSL_GLOBAL_OPTIONS.flashExpressInstallSuffix; },
      getFlashFileUploaderUrl: function(apiKey) { return PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl + PLUCKSL_GLOBAL_OPTIONS.pluckItUploader; },
      prepareServerRequest: function(requests){
        // add the requests in to the batch
        var requestBatch = new RequestBatch();
        for (var i = 0; i < requests.length; i++) {
          requestBatch.AddToRequest(requests[i]);
        }
        return requestBatch;
      },
      extractBatchResponse: function(response){
        if (Object.prototype.toString.call(response) == "[object String]") {
          var response = unescape(response);
          // script prefixed strip if present
          var m = response.match(/^[^\{]*?(\{.+\}[;]*?)\s*$/im);
          if (m != null) {
            response = m[m.length - 1];
          }
          response = response.replace(/\\\>/g, ">");
          response = this.JSON.parse(response);
        }
        if (typeof response.ResponseBatch !== 'undefined') {
          return response.ResponseBatch;
        } else {
          return response;
        }
      },
      // using Yahoo's JSON parser
      JSON: YAHOO.lang.JSON
    }
    dmgroups.createDAAPIRequestService = function(){
      return new dmgroups.PluckRequestService('00000000-0000-0000-0000-000000000000', DAAPIServiceDetails);
    };
    dmgroups.RequestServiceInstances = {};
    // This is the PluckRequestService. Instantiate this to talk to the PluckRequestService.
    // the apiKey is your customer key
    dmgroups.PluckRequestService = function(){
      // query param PLUCK_DEBUG or page level _DEBUG
      //  0 = none, 1 = console level, 2 = alerts for IE
      var debugging = 0;
      var match = location.search.match(new RegExp('[\?&]PLUCK_DEBUG=([^&]+)'));
      if (match) {
        debugging = match[1];
      } else if (typeof(_DEBUG) !== 'undefined') {
        debugging = _DEBUG;
      }
      if (debugging != false && debugging != 'false') {
        if (debugging == true || debugging == 'true') {
          debugging = 1;
        }
      } else {
        debugging = 0;
      }
      this.debugging = {
        level: debugging,
        on: debugging > 0,
        alerts: debugging > 1,
        firebug: false
      };
      this.init.apply(this, arguments);
    }
    dmgroups.PluckRequestService.prototype = (function(){
      // utility functions and classes
      function $(id){
        if (document.getElementById) {
          return document.getElementById(id);
        }
        if (document.all) {
          return document.all[id];
        }
      }
      // SWFObject v2.0 <http://code.google.com/p/swfobject/>
      // Copyright (c) 2007 Geoff Stearns, Michael Williams, and Bobby van der Sluis
      // This software is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
      //  PLUCKNOTE/MEP:  Pluck has added the method 'signalWindowOnLoad' to be called when swfobject was dynamically loaded after the original window onload notification
      //  Search for 'PLUCKNOTE' to see other relavent information
      var swfobject = function(){
        var Z = "undefined", P = "object", B = "Shockwave Flash", h = "ShockwaveFlash.ShockwaveFlash", W = "application/x-shockwave-flash", K = "SWFObjectExprInst", G = window, g = document, N = navigator, f = [], H = [], Q = null, L = null, T = null, S = false, C = false;
        var a = function(){
          var l = typeof g.getElementById != Z && typeof g.getElementsByTagName != Z && typeof g.createElement != Z && typeof g.appendChild != Z && typeof g.replaceChild != Z && typeof g.removeChild != Z && typeof g.cloneNode != Z, t = [0, 0, 0], n = null;
          if (typeof N.plugins != Z && typeof N.plugins[B] == P) {
            n = N.plugins[B].description;
            if (n) {
              n = n.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
              t[0] = parseInt(n.replace(/^(.*)\..*$/, "$1"), 10);
              t[1] = parseInt(n.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
              t[2] = /r/.test(n) ? parseInt(n.replace(/^.*r(.*)$/, "$1"), 10) : 0
            }
          } else {
            if (typeof G.ActiveXObject != Z) {
              var o = null, s = false;
              try {
                o = new ActiveXObject(h + ".7")
              } catch (k) {
                try {
                  o = new ActiveXObject(h + ".6");
                  t = [6, 0, 21];
                  o.AllowScriptAccess = "always"
                } catch (k) {
                  if (t[0] == 6) {
                    s = true
                  }
                }
                if (!s) {
                  try {
                    o = new ActiveXObject(h)
                  } catch (k) {
                  }
                }
              }
              if (!s && o) {
                try {
                  n = o.GetVariable("$version");
                  if (n) {
                    n = n.split(" ")[1].split(",");
                    t = [parseInt(n[0], 10), parseInt(n[1], 10), parseInt(n[2], 10)]
                  }
                } catch (k) {
                }
              }
            }
          }
          var v = N.userAgent.toLowerCase(), j = N.platform.toLowerCase(), r = /webkit/.test(v) ? parseFloat(v.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, i = false, q = j ? /win/.test(j) : /win/.test(v), m = j ? /mac/.test(j) : /mac/.test(v);/*@cc_on i=true;@if(@_win32)q=true;@elif(@_mac)m=true;@end@*/
          return {
            w3cdom: l,
            pv: t,
            webkit: r,
            ie: i,
            win: q,
            mac: m
          }
        }();
        var e = function(){
          if (!a.w3cdom) {
            return
          }
          J(I);
          //PLUCKNOTE/MEP: Because groups is all loading dynamically, the document write is not allowable.  Since I have already
          //added a signalWindowOnLoad function which we call, this will suffice and the following is no longer needed
          //if (a.ie && a.win) {
          //try {
          //      g.write("<script id=__ie_ondomload defer=true src=//:><\/script>");
          //      var i = c("__ie_ondomload");
          //      if (i) {
          //        i.onreadystatechange = function(){
          //          if (this.readyState == "complete") {
          //            this.parentNode.removeChild(this);
          //            V()
          //          }
          //        }
          //      }
          //    } catch (j) {
          //  }
          //}
          //if (a.webkit && typeof g.readyState != Z) {
          //  Q = setInterval(function(){
          //    if (/loaded|complete/.test(g.readyState)) {
          //      V()
          //    }
          //  }, 10)
          //}
          //if (typeof g.addEventListener != Z) {
          //  g.addEventListener("DOMContentLoaded", V, null)
          //}
          //M(V)
        }();
        function V(){
          if (S) {
            return
          }
          if (a.ie && a.win) {
            var m = Y("span");
            try {
              var l = g.getElementsByTagName("body")[0].appendChild(m);
              l.parentNode.removeChild(l)
            } catch (n) {
              return
            }
          }
          S = true;
          if (Q) {
            clearInterval(Q);
            Q = null
          }
          var j = f.length;
          for (var k = 0; k < j; k++) {
            f[k]()
          }
        }
        function J(i){
          if (S) {
            i()
          } else {
            f[f.length] = i
          }
        }
        function M(j){
          //PLUCKNOTE/MEP: Because groups is all loading dynamically, the document write is not allowable.  Since I have already
          //added a signalWindowOnLoad function which we call, this will suffice and the following is no longer needed
          //if (typeof G.addEventListener != Z) {
          //  G.addEventListener("load", j, false)
          //} else {
          //  if (typeof g.addEventListener != Z) {
          //    g.addEventListener("load", j, false)
          //  } else {
          //    if (typeof G.attachEvent != Z) {
          //      G.attachEvent("onload", j)
          //    } else {
          //      if (typeof G.onload == "function") {
          //        var i = G.onload;
          //        G.onload = function(){
          //          i();
          //          j()
          //        }
          //      } else {
          //        G.onload = j
          //      }
          //    }
          //  }
          //}
        }
        function I(){
          var l = H.length;
          for (var j = 0; j < l; j++) {
            var m = H[j].id;
            if (a.pv[0] > 0) {
              var k = c(m);
              if (k) {
                H[j].width = k.getAttribute("width") ? k.getAttribute("width") : "0";
                H[j].height = k.getAttribute("height") ? k.getAttribute("height") : "0";
                if (O(H[j].swfVersion)) {
                  if (a.webkit && a.webkit < 312) {
                    U(k)
                  }
                  X(m, true)
                } else {
                  if (H[j].expressInstall && !C && O("6.0.65") && (a.win || a.mac)) {
                    D(H[j])
                  } else {
                    d(k)
                  }
                }
              }
            } else {
              X(m, true)
            }
          }
        }
        function U(m){
          var k = m.getElementsByTagName(P)[0];
          if (k) {
            var p = Y("embed"), r = k.attributes;
            if (r) {
              var o = r.length;
              for (var n = 0; n < o; n++) {
                if (r[n].nodeName.toLowerCase() == "data") {
                  p.setAttribute("src", r[n].nodeValue)
                } else {
                  p.setAttribute(r[n].nodeName, r[n].nodeValue)
                }
              }
            }
            var q = k.childNodes;
            if (q) {
              var s = q.length;
              for (var l = 0; l < s; l++) {
                if (q[l].nodeType == 1 && q[l].nodeName.toLowerCase() == "param") {
                  p.setAttribute(q[l].getAttribute("name"), q[l].getAttribute("value"))
                }
              }
            }
            m.parentNode.replaceChild(p, m)
          }
        }
        function F(i){
          if (a.ie && a.win && O("8.0.0")) {
            G.attachEvent("onunload", function(){
              var k = c(i);
              if (k) {
                for (var j in k) {
                  if (typeof k[j] == "function") {
                    k[j] = function(){
                    }
                  }
                }
                k.parentNode.removeChild(k)
              }
            })
          }
        }
        function D(j){
          C = true;
          var o = c(j.id);
          if (o) {
            if (j.altContentId) {
              var l = c(j.altContentId);
              if (l) {
                L = l;
                T = j.altContentId
              }
            } else {
              L = b(o)
            }
            if (!(/%$/.test(j.width)) && parseInt(j.width, 10) < 310) {
              j.width = "310"
            }
            if (!(/%$/.test(j.height)) && parseInt(j.height, 10) < 137) {
              j.height = "137"
            }
            g.title = g.title.slice(0, 47) + " - Flash Player Installation";
            var n = a.ie && a.win ? "ActiveX" : "PlugIn", k = g.title, m = "MMredirectURL=" + G.location + "&MMplayerType=" + n + "&MMdoctitle=" + k, p = j.id;
            if (a.ie && a.win && o.readyState != 4) {
              var i = Y("div");
              p += "SWFObjectNew";
              i.setAttribute("id", p);
              o.parentNode.insertBefore(i, o);
              o.style.display = "none";
              G.attachEvent("onload", function(){
                o.parentNode.removeChild(o)
              })
            }
            R({
              data: j.expressInstall,
              id: K,
              width: j.width,
              height: j.height
            }, {
              flashvars: m
            }, p)
          }
        }
        function d(j){
          if (a.ie && a.win && j.readyState != 4) {
            var i = Y("div");
            j.parentNode.insertBefore(i, j);
            i.parentNode.replaceChild(b(j), i);
            j.style.display = "none";
            G.attachEvent("onload", function(){
              j.parentNode.removeChild(j)
            })
          } else {
            j.parentNode.replaceChild(b(j), j)
          }
        }
        function b(n){
          var m = Y("div");
          if (a.win && a.ie) {
            m.innerHTML = n.innerHTML
          } else {
            var k = n.getElementsByTagName(P)[0];
            if (k) {
              var o = k.childNodes;
              if (o) {
                var j = o.length;
                for (var l = 0; l < j; l++) {
                  if (!(o[l].nodeType == 1 && o[l].nodeName.toLowerCase() == "param") && !(o[l].nodeType == 8)) {
                    m.appendChild(o[l].cloneNode(true))
                  }
                }
              }
            }
          }
          return m
        }
        function R(AE, AC, q){
          var p, t = c(q);
          if (typeof AE.id == Z) {
            AE.id = q
          }
          if (a.ie && a.win) {
            var AD = "";
            for (var z in AE) {
              if (AE[z] != Object.prototype[z]) {
                if (z == "data") {
                  AC.movie = AE[z]
                } else {
                  if (z.toLowerCase() == "styleclass") {
                    AD += ' class="' + AE[z] + '"'
                  } else {
                    if (z != "classid") {
                      AD += " " + z + '="' + AE[z] + '"'
                    }
                  }
                }
              }
            }
            var AB = "";
            for (var y in AC) {
              if (AC[y] != Object.prototype[y]) {
                AB += '<param name="' + y + '" value="' + AC[y] + '" />'
              }
            }
            t.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + AD + ">" + AB + "</object>";
            F(AE.id);
            p = c(AE.id)
          } else {
            if (a.webkit && a.webkit < 312) {
              var AA = Y("embed");
              AA.setAttribute("type", W);
              for (var x in AE) {
                if (AE[x] != Object.prototype[x]) {
                  if (x == "data") {
                    AA.setAttribute("src", AE[x])
                  } else {
                    if (x.toLowerCase() == "styleclass") {
                      AA.setAttribute("class", AE[x])
                    } else {
                      if (x != "classid") {
                        AA.setAttribute(x, AE[x])
                      }
                    }
                  }
                }
              }
              for (var w in AC) {
                if (AC[w] != Object.prototype[w]) {
                  if (w != "movie") {
                    AA.setAttribute(w, AC[w])
                  }
                }
              }
              t.parentNode.replaceChild(AA, t);
              p = AA
            } else {
              var s = Y(P);
              s.setAttribute("type", W);
              for (var v in AE) {
                if (AE[v] != Object.prototype[v]) {
                  if (v.toLowerCase() == "styleclass") {
                    s.setAttribute("class", AE[v])
                  } else {
                    if (v != "classid") {
                      s.setAttribute(v, AE[v])
                    }
                  }
                }
              }
              for (var u in AC) {
                if (AC[u] != Object.prototype[u] && u != "movie") {
                  E(s, u, AC[u])
                }
              }
              t.parentNode.replaceChild(s, t);
              p = s
            }
          }
          return p
        }
        function E(k, i, j){
          var l = Y("param");
          l.setAttribute("name", i);
          l.setAttribute("value", j);
          k.appendChild(l)
        }
        function c(i){
          return g.getElementById(i)
        }
        function Y(i){
          return g.createElement(i)
        }
        function O(k){
          var j = a.pv, i = k.split(".");
          i[0] = parseInt(i[0], 10);
          i[1] = parseInt(i[1], 10);
          i[2] = parseInt(i[2], 10);
          return (j[0] > i[0] || (j[0] == i[0] && j[1] > i[1]) || (j[0] == i[0] && j[1] == i[1] && j[2] >= i[2])) ? true : false
        }
        function A(m, j){
          if (a.ie && a.mac) {
            return
          }
          var l = g.getElementsByTagName("head")[0], k = Y("style");
          k.setAttribute("type", "text/css");
          k.setAttribute("media", "screen");
          if (!(a.ie && a.win) && typeof g.createTextNode != Z) {
            k.appendChild(g.createTextNode(m + " {" + j + "}"))
          }
          l.appendChild(k);
          if (a.ie && a.win && typeof g.styleSheets != Z && g.styleSheets.length > 0) {
            var i = g.styleSheets[g.styleSheets.length - 1];
            if (typeof i.addRule == P) {
              i.addRule(m, j)
            }
          }
        }
        function X(k, i){
          var j = i ? "visible" : "hidden";
          if (S) {
            c(k).style.visibility = j
          } else {
            A("#" + k, "visibility:" + j)
          }
        }
        return {
          registerObject: function(l, i, k){
            if (!a.w3cdom || !l || !i) {
              return
            }
            var j = {};
            j.id = l;
            j.swfVersion = i;
            j.expressInstall = k ? k : false;
            H[H.length] = j;
            X(l, false)
          },
          getObjectById: function(l){
            var i = null;
            if (a.w3cdom && S) {
              var j = c(l);
              if (j) {
                var k = j.getElementsByTagName(P)[0];
                if (!k || (k && typeof j.SetVariable != Z)) {
                  i = j
                } else {
                  if (typeof k.SetVariable != Z) {
                    i = k
                  }
                }
              }
            }
            return i
          },
          signalWindowOnLoad: function(){
            V();
          },
          embedSWF: function(n, u, r, t, j, m, k, p, s){
            if (!a.w3cdom || !n || !u || !r || !t || !j) {
              return
            }
            r += "";
            t += "";
            if (O(j)) {
              X(u, false);
              var q = (typeof s == P) ? s : {};
              q.data = n;
              q.width = r;
              q.height = t;
              var o = (typeof p == P) ? p : {};
              if (typeof k == P) {
                for (var l in k) {
                  if (k[l] != Object.prototype[l]) {
                    if (typeof o.flashvars != Z) {
                      o.flashvars += "&" + l + "=" + k[l]
                    } else {
                      o.flashvars = l + "=" + k[l]
                    }
                  }
                }
              }
              J(function(){
                R(q, o, u);
                if (q.id == u) {
                  X(u, true)
                }
              })
            } else {
              if (m && !C && O("6.0.65") && (a.win || a.mac)) {
                X(u, false);
                J(function(){
                  var i = {};
                  i.id = i.altContentId = u;
                  i.width = r;
                  i.height = t;
                  i.expressInstall = m;
                  D(i)
                })
              }
            }
          },
          getFlashPlayerVersion: function(){
            return {
              major: a.pv[0],
              minor: a.pv[1],
              release: a.pv[2]
            }
          },
          hasFlashPlayerVersion: O,
          createSWF: function(k, j, i){
            if (a.w3cdom && S) {
              return R(k, j, i)
            } else {
              return undefined
            }
          },
          createCSS: function(j, i){
            if (a.w3cdom) {
              A(j, i)
            }
          },
          addDomLoadEvent: J,
          addLoadEvent: M,
          getQueryParamValue: function(m){
            var l = g.location.search || g.location.hash;
            if (m == null) {
              return l
            }
            if (l) {
              var k = l.substring(1).split("&");
              for (var j = 0; j < k.length; j++) {
                if (k[j].substring(0, k[j].indexOf("=")) == m) {
                  return k[j].substring((k[j].indexOf("=") + 1))
                }
              }
            }
            return ""
          },
          expressInstallCallback: function(){
            if (C && L) {
              var i = c(K);
              if (i) {
                i.parentNode.replaceChild(L, i);
                if (T) {
                  X(T, true);
                  if (a.ie && a.win) {
                    L.style.display = "block"
                  }
                }
                L = null;
                T = null;
                C = false
              }
            }
          }
        }
      }();
      var flashInstalled = false;
      var transport = typeof PLUCK_TRANSPORT !== 'undefined' ? PLUCK_TRANSPORT.toLowerCase() : null;
      var m = document.location.toString().match(/PLUCK_TRANSPORT=([a-z]+)/i);
      if (m && m.length > 0) {
        transport = m[1].toLowerCase();
      }
      // setting transport to jsonp will turn off flash transport
      if (transport != "jsonp") {
        try {
          flashInstalled = parseInt(swfobject.getFlashPlayerVersion().major) >= 9;
        } catch(e) {
        }
      }
      return {
        constructor: dmgroups.PluckRequestService,
        swfobject: swfobject,
        _flashInstalled: flashInstalled,
        _flashReady: false,
        init: function(apiKey, serviceDetails){
          this.fileUploadingEnabled = false;
          this.fileUploaderId = '';
          this.serviceDetails = serviceDetails;
          this.apiKey = apiKey;
          this._pendingRequests = [];
          this.instanceID = 'pluckit_' + this.uniqueID()
          // Call PLUCKSL_GLOBAL_OPTIONS to find out if view tracking is either enabled or disabled.
          this.viewTrackingEnabled = PLUCKSL_GLOBAL_OPTIONS.viewTrackingEnabled;
          this._callbackDictionary = {};
          var my = this;
          this.initProxy = (function(my){
            return function(){
              // now that DOM is complete ... if we aren't using flash, then go ahead and start
              // processing the queue with jsonp
              if (!my._flashInstalled) {
                my.processQueue();
                return;
              }
              //PLUCKNOTE/MEP: since the onload has already happend, we need to signal this fact to swfobject who would otherwise wait for it!
              swfobject.signalWindowOnLoad();
              // load the flash tunnel
              // create a placeholder for the flash tunnel on the page
              var flashObject = document.body.appendChild(document.createElement('div'));
              flashObject.id = 'flashProxy_' + my.instanceID + '_DIV';
              // create a placeholder for the flash file uploader
              my.fileUploaderId = 'flashFileUploader_' + this.instanceID;
              my.fileUploaderDiv = document.body.appendChild(document.createElement('div'));
              my.fileUploaderDiv.id = my.fileUploaderId + '_DIV';
              // Set up the variables for swfobject
              var swfUrl = my.serviceDetails.getFlashTunnelUrl(my.apiKey);
              var swfId = 'flashProxy_' + my.instanceID;
              var swfWidth = '0';
              var swfHeight = '0';
              var swfVersion = '9.0.0';
              var flashvars = {
                onLoadCallbackName: 'dmgroups.RequestServiceInstances[\'' + my.instanceID + '\'].__flash__ready',
                onStatusCallbackName: 'dmgroups.RequestServiceInstances[\'' + my.instanceID + '\'].__flash__status'
              };
              var params = {
                autostart: 'true',
                width: swfWidth,
                height: swfHeight,
                allowFullScreen: 'true',
                allowScriptAccess: 'always'
              };
              var attributes = {};
              // Write out the Flash object
              //swfobject.(swfUrl, swfId, swfWidth, swfHeight, swfVersion, my.serviceDetails.getFlashExpressInstallUrl(my.apiKey), flashvars, params, attributes)

              window[my.instanceID+'flashready'] = function() { my.__flash__ready(); };
              window[my.instanceID+'flashstatus'] = function(status) { my.__flash__ready(status); };
              var fvars = 'onLoadCallbackName='+my.instanceID+'flashready&onStatusCallbackName='+my.instanceID+'flashstatus';
              my.loadFlashCount = 0;
              my.loadFlash = function() {
                if (my.loadFlashCount <= 1) { // allow one addition load
                  my.loadFlashCount++;
                  my._flashReady = false;
                  my.safeEmbedSWF(flashObject, swfId, swfUrl, 0, 0, fvars, "9.0.0", my.serviceDetails.getFlashExpressInstallUrl(my.apiKey));
                }
              }
              my.loadFlash();
            };
          })(my);
          this.serverUrl = this.serviceDetails.getServerUrl(this.apiKey, this.getUserAuthToken());
          // register our instance for flash and jsonp callbacks
          dmgroups.RequestServiceInstances[this.instanceID] = this;
          // we need to wait until the DOM is complete before any request processing.
          // we will start processing within 'initProxy' at that time.
          if (document.body && ((typeof document.readyState == 'undefined') || /loaded|complete/.test(document.readyState))) { // setup the proxy
            this.initProxy();
          } else {
            this.addLoadEvent(this.initProxy);
          }
        },
        debug: function(data) {
            if (typeof(this.firebugDetected) === 'undefined') {
                if (typeof(window.console) !== 'undefined' && typeof(window.console.firebug) !== 'undefined' && parseFloat(window.console.firebug) >= 1.05) {
                  this.debugging.firebug = true;
                }
                this.firebugDetected = true;
            }
          if (this.debugging.on) {
            if (window.opera) {
              opera.postError(data);
            } else if (window.console) {
              console.log(data);
            } else if (this.debugging.alerts) {
              alert(data);
            }
          }
        },
        // this function is here because using swfobject caused a crash in IE on successive refreshes and ctrl-refreshes during page unload - this doesn't
        safeEmbedSWF: function(hostObj, swfId, swfUrl, width, height, flashvars, version, expressInstallUrl) {
          var ie=(navigator.userAgent.indexOf('MSIE')!= -1 && navigator.userAgent.indexOf('Opera') == -1);
          if (ie && swfobject.getFlashPlayerVersion().major == "0") return;
          if (ie) {
            hostObj.innerHTML = '<OBJECT id='+swfId+' style="VISIBILITY: visible" height=0 width=0 classid=clsid:D27CDB6E-AE6D-11cf-96B8-444553540000> \
              <PARAM NAME="FlashVars" VALUE="'+flashvars+'">\
              <PARAM NAME="Movie" VALUE="'+swfUrl+'">\
              <PARAM NAME="Src" VALUE="'+swfUrl+'">\
              <PARAM NAME="AllowScriptAccess" VALUE="always">\
              <PARAM NAME="AllowNetworking" VALUE="all">\
              <PARAM NAME="AllowFullScreen" VALUE="true">\
              <PARAM NAME="Width" VALUE="'+width+'">\
              <PARAM NAME="Height" VALUE="'+height+'">\
              </OBJECT>';
          } else {
            hostObj.innerHTML = '<object id="'+swfId+'" width="'+width+'" height="'+height+'" type="application/x-shockwave-flash" data="'+swfUrl+'" style="visibility: visible;">\
              <param name="autostart" value="true"/>\
              <param name="width" value="'+width+'"/>\
              <param name="height" value="'+height+'"/>\
              <param name="allowFullScreen" value="true"/>\
              <param name="allowScriptAccess" value="always"/>\
              <param name="flashvars" value="'+flashvars+'"/>\
              </object>';              
          }
          swfobject.registerObject(swfId, version, expressInstallUrl);
        },
        processQueue: function(){
          if (!this._flashInstalled || this._flashReady) {
            while (this._pendingRequests.length > 0) {
              var func = this._pendingRequests.pop();
              func();
              // make sure flash wasn't unload somehow during call
              if (this._flashInstalled && typeof(this._flashProxy.CallDAPI) === 'undefined') {
                // schedule the function to be called again
                this._pendingRequests.push(func);
                this.debug('trying to reload flash');
                this.loadFlash(); // try to reload it (will only allow one reload)
                break;
              }
            }
          }
        },
        _registerCallback: function(callback){
          // store the callback in the dictionary, the flash layer can only pass names
          var asyncToken = 'request_' + this.uniqueID();
          this._callbackDictionary[asyncToken] = callback;
          return asyncToken;
        },
        uniqueID: function(){
          var seed = (new Date()).getTime();
          return Math.floor(Math.random() * seed);// + '_' + Math.floor(Math.random() * seed);
        },
        DownloadUrl: function(serverUrl, queryString, callback){
          var me = this;
          // this is a queue that holds requests for the brief period of time required for flash to initialize
          this._pendingRequests.push(function(){
            me._download(serverUrl, queryString, callback);
          });
          this.debug('[DownloadUrl/id:' + this.instanceID + '] queuing request -- total: ' + this._pendingRequests.length);
          this.processQueue();
        },
        _download: function(serverUrl, queryString, callback){
          // register callback
          var asyncToken = this._registerCallback(callback);
          if (queryString) {
            queryString = escape(queryString);
          }
          callback.flashProxyCallType = function() { return 'DownloadUrl'; };
          this._flashProxy.DownloadUrl(serverUrl, queryString, 'dmgroups.RequestServiceInstances[\'' + this.instanceID + '\'].__flash__callback', asyncToken);
        },
        PostForm: function(serverUrl, queryString, callback){
          var me = this;
          // this is a queue that holds requests for the brief period of time required for flash to initialize
          this._pendingRequests.push(function(){
            me._post(serverUrl, queryString, callback);
          });
          this.debug('[PostForm/id:' + this.instanceID + '] queuing request -- total: ' + this._pendingRequests.length);
          this.processQueue();
        },
        _post: function(serverUrl, queryString, callback){
          // register callback
          var asyncToken = this._registerCallback(callback);
          callback.flashProxyCallType = function() { return 'PostForm'; };
          this._flashProxy.PostForm(serverUrl, escape(queryString), 'dmgroups.RequestServiceInstances[\'' + this.instanceID + '\'].__flash__callback', asyncToken, document.location.toString());
        },
        IsFlashInstalled: function() { 
          return this._flashInstalled; 
        },
        SendRequests: function(requests, callback){
          var me = this;
          // this is a queue that holds requests for the brief period of time required for flash to initialize
          this._pendingRequests.push(function(){
            me._transmit(requests, callback);
          });
          this.processQueue();
        },
        _transmit: function(requests, callback){
          // register callback
          var asyncToken = this._registerCallback(callback);
          var requestBatch = this.serviceDetails.prepareServerRequest(requests);
          var jsonRequest = this.serviceDetails.JSON.stringify(requestBatch);
          if (this.debugging.on && this.debugging.firebug) {
            console.group('SENDING REQUESTS TO SERVER - %s', asyncToken);
            for (var i=0;i<requests.length;i++) { console.group('Request['+i+']'); console.dir(requests[i]); console.groupEnd(); }
            console.groupEnd();
            console.time(asyncToken);
          }
          if (this._flashInstalled) {
						// Post the requests to the server via the flash proxy. We pass in the asyncToken
						// because flash can't handle the actual callback functions. The proxy returns they asyncToken
						// back to us on the callback, which we can use to locate and execute the callback function
						// do a last minute check in case flash has become disabled for some reason
						// return true if called, false if not
						if (this._flashReady && typeof(this._flashProxy.CallDAPI) !== 'undefined') {
							// Insert tracker image node for stat tracking if enabled.
							if(this.viewTrackingEnabled === 'True') {
								this._initializeTracking(); 
							}
							// mark this call so we no to do DAPI batch response extraction on it
							callback.flashProxyCallType = function() { return 'CallDAPI'; };
							this.debug('[CallDAPI/id:' + this.instanceID + '] queuing request -- total: ' + this._pendingRequests.length);
							if ((this.serverUrl.match(/^https/i) == null) && (document.cookie.toLowerCase().indexOf("hd=") == -1) && (document.cookie.toLowerCase().indexOf("at=") == -1)
									&& ((this.serverUrl.length + escape(jsonRequest).length) < 2083)) {
									this.debug('DAAPI request made via GET');
									this._flashProxy.CallDAPIAsGet(this.serverUrl, jsonRequest, 'dmgroups.RequestServiceInstances[\'' + this.instanceID + '\'].__flash__callback', asyncToken, document.location.toString(), false);
							} else {
									this.debug('DAAPI request made via POST');
									this._flashProxy.CallDAPI(this.serverUrl, jsonRequest, 'dmgroups.RequestServiceInstances[\'' + this.instanceID + '\'].__flash__callback', asyncToken, document.location.toString());
							}
						}
          } else {
						// Insert tracker image node for stat tracking if enabled.
						if(this.viewTrackingEnabled === 'True') {
							this._initializeTracking(); 
						}
            // for this customer patch - add a uid to the url to bypass browser cache like the Flash Post above has always done
            var separator = this.serverUrl.indexOf('?') == -1 ? "?" : "&";
            var requestUrl = this.serverUrl + separator+'uid='+Math.floor(Math.random()*0x7fffffff);
            // using jsonp - call through to old daapi batch request code
            var my = this;
            requestBatch.BeginRequest(requestUrl, function(responses){
               my.jsonpCallback(responses, asyncToken);
            });
          }
        },
        _initializeTracking: function() {
          	var requestUrl = location.href;
          	var userIdTrckr = this._getCurrentUserFromCookie();
          	var d = new Date();
          	var me = this;
          	
          	// We are using jQuery's object detection to determine if the browser is ready for us
			// to insert our stat tracker node.
			// Mozilla, Opera and webkit nightlies currently support this event
			if (document.addEventListener) {
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", function(){
					document.removeEventListener( "DOMContentLoaded", arguments.callee, false );
					me._insertTrackerNode(me.serverUrl, requestUrl, userIdTrckr, me.gcid, d.getTime());
				}, false );
				
			// If IE event model is used
			} else if (document.attachEvent) {						
				// ensure firing before onload,
				// maybe late but safe also for iframes
				document.attachEvent("onreadystatechange", function(){
					if ( document.readyState === "complete" ) {
						document.detachEvent( "onreadystatechange", arguments.callee );
						me._insertTrackerNode(me.serverUrl, requestUrl, userIdTrckr, me.gcid, d.getTime());
					}
				});

				// If IE and not an iframe
				// continually check to see if the document is ready
				if ( document.documentElement.doScroll && window == window.top ) (function(){

					try {
						// If IE is used, use the trick by Diego Perini
						// http://javascript.nwbox.com/IEContentLoaded/
						document.documentElement.doScroll("left");
					} catch( error ) {
						setTimeout( arguments.callee, 0 );
						return;
					}

					// and execute any waiting functions
					me._insertTrackerNode(me.serverUrl, requestUrl, userIdTrckr, me.gcid, d.getTime());
				})();
			}
        },
        __flash__ready: function(){
          var proxy = $('flashProxy_' + this.instanceID);
          if (proxy != null && typeof(proxy.CallDAPI) !== 'undefined') {
            this.debug('Flash is ready');
            this._flashProxy = proxy;
            this._flashReady = true;
            // process the queue if any requests were submitted before the proxy was ready
            this.processQueue();
          } else {
            this.debug('Flash ready failed!');
          }
        },
        __flash__status: function(status){
          this.debug('flash proxy status: '+status);
        },
        __flash__callback: function(successful, response, asyncToken){
          if (this.debugging.on && this.debugging.firebug) { console.timeEnd(asyncToken); }
          try {
            if (!successful) {
              this.onError('Communication error');
              // if responses is an array return the array
              // otherwise we thrown an exception? not async cool?
              // should we pass a map of "success" and "error" handlers?
              return;
            }
            // fetch the caller's callback from the dictionary
            var callback = this._callbackDictionary[asyncToken];
            // remove it from the dictionary, we are done with it
            delete this._callbackDictionary[asyncToken];
            response = unescape(response);
            // extract the batch responses if this was a DAPI call
            if (callback.flashProxyCallType() == 'CallDAPI') {
              var batchResponse = this.serviceDetails.extractBatchResponse(response);
              if (this.debugging.on && this.debugging.firebug) {
                console.group('RECEIVED RESPONSES FROM SERVER - %s', asyncToken);
                for (var i=0;i<batchResponse.Responses.length;i++) { console.group('Response['+i+']'); console.dir(batchResponse.Responses[i]); console.groupEnd(); }
                console.groupEnd();
              }
              callback(batchResponse);
            } else {
              callback(response);
            }
          } catch (e) {
            this.onError(e);
          }
        },
        jsonpCallback: function(response, asyncToken) {
          if (this.debugging.on && this.debugging.firebug) { console.timeEnd(asyncToken); }
          try {
            // fetch the caller's callback from the dictionary
            var callback = this._callbackDictionary[asyncToken];
            // remove it from the dictionary, we are done with it
            delete this._callbackDictionary[asyncToken];
            var batchResponse = this.serviceDetails.extractBatchResponse(response);
            if (this.debugging.on && this.debugging.firebug) {
              console.group('RECEIVED RESPONSES FROM SERVER - %s', asyncToken);
              for (var i=0;i<batchResponse.Responses.length;i++) { console.group('Response['+i+']'); console.dir(batchResponse.Responses[i]); console.groupEnd(); }
              console.groupEnd();
            }
            callback(batchResponse);
          } catch (e) {
            this.onError(e);
          }
        },
        addLoadEvent: function(func){
          if (window.addEventListener) 
            window.addEventListener('load', func, false);
          else 
            if (window.attachEvent) 
              window.attachEvent('onload', func);
            else { /* epic fail */
            }
        },
        enableFileUploading: function(){
          if (!this.fileUploadingEnabled) {
            this.fileUploadingEnabled = true;
              // load the file uploader component
              // Set up the variables for swfobject
              var swfUrl = this.serviceDetails.getFlashFileUploaderUrl(this.apiKey);
              if (swfUrl > '') {
                // Write out the Flash object
                this.safeEmbedSWF(this.fileUploaderDiv, this.fileUploaderId, swfUrl, 0, 0, {}, '9.0.0', this.serviceDetails.getFlashExpressInstallUrl(this.apiKey));
            }
          };
          
        },
        uploadFile: function(serverUrl, mediaTypesPrompt, mediaTypesFilter, callerThis, responseCallback, progressCallback){
          var response = 'callback' + this.uniqueID();
          var progress = 'callback' + this.uniqueID();
          window[response] = function(success, data){
            responseCallback.apply(callerThis, arguments);
          };
          window[progress] = function(percent){
            progressCallback.apply(callerThis, arguments);
          };
          document[this.fileUploaderId].PerformUpload(serverUrl, mediaTypesPrompt, mediaTypesFilter, response, progress);
        },
        // others need access to JSON and SWFObject - so these helpers are included
        JsonStringify: function(what){
          return this.serviceDetails.JSON.stringify(what);
        },
        JsonParse: function(what){
          return this.serviceDetails.JSON.parse(what);
        },
        getHost: function(){
          return this.serviceDetails.getHost();
        },
        getSwfObject: swfobject,
        getClientCookieName: function(){
          // set the client side cookie name for authentication/holding of the pluck at auth token
          if (typeof PLUCKIT_CLIENTCOOKIENAME != 'undefined') {
            return PLUCKIT_CLIENTCOOKIENAME;
          } else {
            return 'piat';
          }
        },
        isUserLoggedIn: function(){
          return typeof(this.getUserAuthToken()) !== 'undefined';
        },
        getUserAuthToken: function(){
          var cookies = document.cookie;
          if (cookies) {
            cookies = ";" + cookies + ";";
            var matches = cookies.match(new RegExp(';\\s*' + this.getClientCookieName() + '=(.+?);'));
            if (matches && matches.length > 1) {
              return matches[1];
            }
          }
        },
        setUserAuthToken: function(token){
          if (token) {
            document.cookie = this.getClientCookieName() + '=' + escape(token);
          } else {
            var d = new Date();
            d.setTime(d.getTime() - 86400000 /* 1 earth day */);
            document.cookie = this.getClientCookieName() + '=; expires=' + d.toGMTString();
            ;
          }
          this.serverUrl = this.serviceDetails.getServerUrl(this.apiKey, escape(token));
        },
        getCookieValue: function(cookieName){
          var cookies = document.cookie;
          if (cookies) {
            cookies = ";" + cookies + ";";
            var matches = cookies.match(new RegExp(';\\s*' + cookieName + '=(.+?);'));
            if (matches && matches.length > 1) {
              return matches[1];
            }
          }
        },
        setCookieValue: function(cookieName, cookieValue, expiresDay){
          var d = new Date();
          d.setTime(d.getTime() + (expiresDay * 86400000));
          document.cookie = cookieName + '=' + cookieValue + '; expires=' + d.toGMTString();
        },
        changeApiKey: function(apiKey){
          this.apiKey = apiKey;
          this.serverUrl = this.serviceDetails.getServerUrl(this.apiKey, this.getUserAuthToken());
        },
        _getCurrentUserFromCookie: function(){
        	var ca = document.cookie.split(';');
		    for (var i = 0; i < ca.length; i++) {
		        var c = ca[i];
		        while (c.charAt(0) === " ") c = c.substring(1, c.length);
		        var eqIndex = c.indexOf("=");
		        if (eqIndex > 0) {
		            name = c.substring(0, eqIndex);
		            value = c.substring(eqIndex + 1);
		            if (name.toLowerCase() == 'hd') {
		                value = unescape(value);
		                value = value.split('|');
				            	
		                return value[0];
		            }
		        }
		    }
		    return null;	
        },
        _createSrcUrl: function(baseUrl, url, userId, gcid, currentTime) {
    		return srcUrl = baseUrl.replace('/Direct/Process', '/Stats/Tracker.gif') + "?plckUrl=" + encodeURIComponent(url) + "&plckUserId=" + userId + "&plckGcid=" + gcid + "&plckCurrentTime=" + currentTime;
        },
        _insertTrackerNode: function(serverUrl, requestUrl, userIdTrckr, gcid, currentTime) {
			if (document.getElementById('slImgNodeTrckr') === null) {
				var trackImgNode = document.createElement('img');
				trackImgNode.setAttribute('id', "slImgNodeTrckr");
				trackImgNode.setAttribute('src', this._createSrcUrl(serverUrl, requestUrl, userIdTrckr, gcid, currentTime));
				if (trackImgNode.style && trackImgNode.style.setAttribute) {
					trackImgNode.style.setAttribute('display', 'none');
				} else {
					trackImgNode.setAttribute('style', 'display:none');
				}
				document.getElementsByTagName('body')[0].appendChild (trackImgNode);
			}
        },
        gcid: "Widgets2.0",
        // override me
        onError: function(e){
          this.debug('Error: ' + e);
          if (this.debugging.on && this.debugging.firebug) {
            console.trace();
          }
        }
      };
    })();
  }
})();
if (typeof(pluckSlService) === 'undefined') {
  pluckSlService = dmgroups.createDAAPIRequestService();
}
//
//  !!!    NOTE:  This file is used by both GROUPS and POD .. do not edit this file unless you have coordinated as such  !!!
//
if (typeof(PluckWidgetHelperBase) == 'undefined') {
  var PluckWidgetHelperBase = function(){
    return {
      extendObjectWith: function(destination, source){
        for (var _var in source) {
          destination[_var] = source[_var];
        }
      },
      isArray: function(obj){
        if (obj.constructor.toString().indexOf("Array") == -1) {
          return false;
        } else {
          return true;
        }
      },
      isFunction: function(obj){
        if (obj.constructor.toString().indexOf("function") == -1) {
          return false;
        } else {
          return true;
        }
      },
      createUniqueId: function(prefix){
        var id = (Math.random() + '_' + Math.random()).replace(/\./g, '');
        if (typeof prefix !== 'undefined') {
          id = prefix + '_' + id;
        }
        return id;
      }, // creates a unique div for the widget content
      addWidgetDiv: function(prefix, suffix){
        var divId = null;
        if (typeof prefix === 'undefined') {
          prifix = 'div';
        }
        if (typeof suffix === 'undefined') {
          divId = createUniqueId(prefix);
        } else {
          divId = prefix + '_' + suffix;
        }
        document.write('<div id="' + divId + '"><\/div>');
        return divId;
      }, // creates a unique textarea for the widget template
      addTemplateHolder: function(html){
        var id = createUniqueId('templateDiv-');
        document.write('<textarea id="' + id + '" style="display: none">' + html + '<\/textarea>');
        return id;
      },
      makeErrorSpan: function(text){
      if (pluckSlService.debugging.on) {
        pluckSlService.debug('WidgetError - ' + text);
          return '<span style="display: block;">WidgetError - ' + text + '</span>';
        } else {
          return '<span style="display: none;">WidgetError - ' + text + '</span>';
        }
      }, // adds the widget stylesheet to the top of the head
      addWidgetStylesheet: function(url, global){
        if (typeof(url) !== 'undefined') {
          // don't add stylesheet twice
          if (!this.stylesheets.hasOwnProperty(url)) {
            this.stylesheets[url] = true;
            var headElem = document.getElementsByTagName('head')[0];
            if (headElem !== null) {
              // set up the link element pointing to this stylesheet
              var linkElem = this.os_createElement('link', {
                'rel': 'stylesheet',
                'type': 'text/css',
                'href': url
              }, '');
              var first = headElem.firstChild;
              if (first == null) {
                // no children to be ahead of, so just add it
                headElem.appendChild(linkElem);
              } else 
                if (typeof(global) !== 'undefined' && global == true) {
                  // put the stylesheet first, if we can
                  headElem.insertBefore(linkElem, first);
                } else {
                  var second = first.nextSibling;
                  if (second == null) {
                    // no children to be ahead of, so just add it
                    headElem.appendChild(linkElem);
                  } else {
                    // put the stylesheet first, if we can
                    headElem.insertBefore(linkElem, second);
                  }
                }
            }
          }
        }
      },
      isBasicType: function(varType){
        return ":string:number:boolean:".indexOf(':' + varType + ':') > -1;
      },
      overrideOptions: function(from, to){
        for (var option in from) {
          if (this.isBasicType(typeof(from[option]))) {
            to[option] = from[option];
          } 
          else if (typeof(from[option]) == 'object') {
			if (!to.hasOwnProperty(option) || this.isBasicType(typeof(to[option]))) {
				to[option] = {};
			} 
          
            if (to[option].constructor.toString() != "Function") {
              this.overrideOptions(from[option], to[option]);
            }
          } 
          else if (typeof(from[option]) == 'function') {
            to[option] = from[option];
          }
        }
      },
      inheritOptions: function(options, parent){
        for (var option in options) {
          if (this.isBasicType(typeof(options[option]))) {
            if (options[option] == '_') {
              if (parent != null && parent.hasOwnProperty(option)) {
                options[option] = parent[option];
              } else {
                options[option] = '';
              }
            }
          } else 
            if (typeof(options[option]) === 'object' && options[option] != null) {
                // read the options object to do more complex behavior
                var optionsObj = options[option];
                if (optionsObj && optionsObj.slParentOption && parent.hasOwnProperty(optionsObj.slParentOption)) {
                  options[option] = parent[optionsObj.slParentOption];
                }
                else if (optionsObj.constructor.toString() != "Function") {
                    this.inheritOptions(options[option], options);
                }
                else {
                  options[option] = '';
                }              
            }
        }
      },
      getTrimPathModifiers: function(){
        var my = this;
        return {
          resolveWidgetResource: function(str){
            return my.resolveWidgetResource(str);
          },
          resolveAssetsResource: function(str){
            return my.resolveAssetsResource(str);
          },
          addQueryParam: function(str, name, value){
            return my.addQueryParam(str, name, value);
          },
          addQueryParams: function(str, nameValuePairs){
            return my.addQueryParams(str, nameValuePairs);
          },
          addPrefixedQueryParam: function(str, name, value){
            return my.addPrefixedQueryParam(str, name, value);
          },
          addPrefixedQueryParams: function(str, nameValuePairs){
            return my.addPrefixedQueryParams(str, nameValuePairs);
          },
          titleEncode: function(str){
            return escape(str.replace(/ /g, '_'));
          },
          urlEscape: function(str){
            return escape(str);
          },
          singleQuoteEscape: function(str){
          return str.replace(/'/g, "\\'");
          }
        }
      }, // Prefix for query params to avoid name collisions
      queryParamPrefix: 'PLUCK',
      getPrefixedQueryParam: function(parameterName){
        return this.getQueryParam(this.queryParamPrefix + parameterName);
      },
      getQueryParam: function(parameterName){
        var match = location.search.match(new RegExp('[\?&]' + parameterName + '=([^&]+)'));
        var value = match ? match[1] : null;
        if (value == null) {
          return null;
        }
        // unescape doesn't deal with +'s so translate to spaces...
        value = value.replace('+', '%20');
        return unescape(value);
      },
      replaceQueryParams: function(url, newParams){
        // remove the anchor
        if (url.indexOf('#') != -1) {
          url = url.substring(0, url.indexOf('#'));
        }
        var urlBase;
        var params = newParams;
        if (url.indexOf('?') != -1) {
          var urlParts = url.split('?');
          urlBase = urlParts[0];
          var search = urlParts[1];
          // remove ? then split on &
          var paramArray = search.split('&');
          params = {};
          for (var index = 0; index < paramArray.length; index++) {
            var keyVal = paramArray[index].split('=');
            params[keyVal[0]] = keyVal[1];
          }
          for (newParam in newParams) {
            params[newParam] = newParams[newParam];
          }
        } else {
          // no existing query params means this is easy
          urlBase = url;
        }
        // join our params dictionary into a string of url params
        var urlParams = "";
        for (param in params) {
          if (urlParams != "") {
            urlParams += "&";
          }
          urlParams += param + "=" + params[param];
        }
        return urlBase + "?" + urlParams;
      },
      ensureHostUrl: function(hostUrl, allowRelative){
        if (typeof(hostUrl) != 'undefined' && hostUrl != null && !allowRelative) {
          var lower = hostUrl.toLowerCase();
          if (lower.indexOf("http") != 0) {
            hostUrl = '';
          }
        }
        if (typeof(hostUrl) == 'undefined' || hostUrl == null || hostUrl == '') {
          hostUrl = document.location.href;
          var stopChars = "#"; // Stripping off in-page navigation. Query params are okay.
          for (i = 0; i < stopChars.length; ++i) {
            var index = hostUrl.indexOf(stopChars.charAt(i));
            if (index > 0) {
              hostUrl = hostUrl.substring(0, index);
            }
          }
        }
        return hostUrl;
      },
      addPrefixedQueryParam: function(url, name, value){
        return this.addQueryParam(url, this.queryParamPrefix + name, value);
      },
      addPrefixedQueryParams: function(url, nameValuePairs){
        for (var name in nameValuePairs) {
          url = this.addPrefixedQueryParam(url, name, nameValuePairs[name]);
        }
        return url;
      },
      addQueryParam: function(url, name, value){
        var regex = new RegExp('([\\?&])' + name + '=[^&;]+');
        var data = name + '=' + value.replace(/\s/g, '_');
        if (regex.test(url)) 
          return url.replace(regex, '$1' + data);
        return url + (url.indexOf('?') > -1 ? '&' : '?') + data;
      },
      addQueryParams: function(url, nameValuePairs){
        for (var name in nameValuePairs) {
          url = this.addQueryParam(url, name, nameValuePairs[name]);
        }
        return url;
      },
      replaceHTMLDivIds: function(html, divId, newDivId){
        html = html.replace(/\r/gm, '---CR---');
        html = html.replace(/\n/gm, '---LF---');
        var m = html.match(new RegExp('^(.*<div.*\\sid\\s*=\\s*[\'\"])(' + divId + ')([\'\"].*?>.*$)', 'i'));
        if (m != null && m.length == 4) {
          html = m[1] + newDivId + m[3];
        }
        html = html.replace(/---CR---/gm, '\r');
        html = html.replace(/---LF---/gm, '\n');
        return html;
      },
      os_createElement: function(elementType, attributes, bodyText){
        var element = document.createElement(elementType);
        for (name in attributes) {
          element.setAttribute(name, attributes[name]);
        }
        if (bodyText.length > 0) {
          element.appendChild(document.createTextNode(bodyText));
        }
        return element;
      },
      os_addToHead: function(elem){
        var head = document.getElementsByTagName("head")[0];
        head.appendChild(elem);
      },
      os_addScriptSrcNode: function(scriptSrc){
        var scriptElement = this.os_createElement('script', {
          'src': scriptSrc,
          'type': 'text/javascript',
          'charset': 'utf-8'
        }, '');
        this.os_addToHead(scriptElement);
      },
      os_addScriptTextNode: function(scriptText){
        var scriptElement = this.os_createElement('script', {
          'type': 'text/javascript',
          'charset': 'utf-8'
        }, scriptText);
        this.os_addToHead(scriptElement);
      },
      displayElement: function(elem, mode){
        document.getElementById(elem).style.display = mode;
      },
      swapElements: function(elemToHide, elemToShow){
        var hideMe = (typeof elemToHide == 'string' ? document.getElementById(elemToHide) : elemToHide), showMe = (typeof elemToShow == 'string' ? document.getElementById(elemToShow) : elemToShow);
        hideMe.style.display = 'none';
        showMe.style.display = 'block';
      },
      addListener: function(element, type, expression, bubbling){
        bubbling = bubbling || false;
        if (window.addEventListener) { // Non-IE browsers

          element.addEventListener(type, expression, bubbling);
          return true;
        } else 
          if (window.attachEvent) { // IE

            element.attachEvent('on' + type, expression);
            return true;
          } else {
            return false;
          }
      },
      removeListener: function(element, type, expression, bubbling){
        bubbling = bubbling || false;
        if (window.removeEventListener) { // Non-IE browsers

          element.removeEventListener(type, expression, bubbling);
          return true;
        } else 
          if (window.detachEvent) { // IE

            element.detachEvent('on' + type, expression);
            return true;
          } else {
            return false;
          }
      },
      // Position changer with Memory by www.hesido.com
      moveElement: function(elem, startPos, endPos, steps, intervals, powr){
        if (elem.posChangeMemInt) {
          window.clearInterval(elem.posChangeMemInt);
        }
        var my = this;
        var actStep = 0;
        elem.posChangeMemInt = window.setInterval(function(){
          if (typeof(startPos[0]) !== 'undefined' &&
          typeof(startPos[1]) !== 'undefined' &&
          typeof(endPos[0]) !== 'undefined' &&
          typeof(endPos[1]) !== 'undefined') {
            elem.currentPos = [my.easeInOut(startPos[0], endPos[0], steps, actStep, powr), my.easeInOut(startPos[1], endPos[1], steps, actStep, powr)];
            elem.style.left = elem.currentPos[0] + "px";
            elem.style.top = elem.currentPos[1] + "px";
            actStep++;
            if (actStep > steps) {
              window.clearInterval(elem.posChangeMemInt);
            }
          } else {
            window.clearInterval(elem.posChangeMemInt);
          }
        }, intervals);
      },
      // Generic Animation Step Value Generator By www.hesido.com
      easeInOut: function(minValue, maxValue, totalSteps, actualStep, powr){
        var delta = maxValue - minValue;
        var stepp = minValue + (Math.pow(((1 / totalSteps) * actualStep), powr) * delta);
        return Math.ceil(stepp)
      },
      // Opacity changer 
      changeOpacity: function(elem, startOpacity, endOpacity, steps, intervals, powr){
        if (elem.opacityChangeMemInt) {
          window.clearInterval(elem.opacityChangeMemInt);
        }
        var my = this;
        var actStep = 0;
        elem.opacityChangeMemInt = window.setInterval(function(){
          elem.currentOpacity = my.easeInOut(startOpacity, endOpacity, steps, actStep, powr);
          elem.style.opacity = elem.currentOpacity / 100;
          elem.style.filter = 'alpha(opacity=' + elem.currentOpacity + ');';
          actStep++;
          if (actStep > steps) {
            if (elem.style.opacity == '0') {
              elem.style.display = 'none';
            }
            window.clearInterval(elem.opacityChangeMemInt);
          }
        }, intervals)
      },
      submitForm: function(name){
        var form = document.forms[name];
        if (form && form.onsubmit()) 
          form.submit();
        return false;
      },
      alert: function(msg){
        var my = this;
        var doc = document, div = doc.body.appendChild(document.createElement('div'));
        div.className = 'podStatusAlert';
        div.appendChild(doc.createTextNode(msg));
        setTimeout(function(){
          my.changeOpacity(div, 100, 0, 20, 30, 1);
          setTimeout(function(){
            doc.body.removeChild(div)
          }, 3000);
        }, 3000)
      },
      stylesheets: {}
    };
  }
}
if (typeof window.PluckWidgetBase == 'undefined') {
  PluckWidgetBase = function(helper){
    this.helper = helper;
  }
  PluckWidgetBase.prototype = (function(){
    return {
      constructor: PluckWidgetBase,
      init: function(parent, classname, instanceName, options, events){
        this.parent = parent;
        this.classname = classname;
        this.instanceName = instanceName;
        this.completedFired = false;
        this.context = {};
        this.context._MODIFIERS = this.helper.getTrimPathModifiers();
        this.context.options = options;
        this.childWidgetsCompleted = [];
        this.events = events || {};
        for (var event in this.events) {
          if (this.events.hasOwnProperty(event)) {
            this.addEventCallback(event, this.events[event]);
          }
        }
        if (typeof(PLUCKIT_APIKEY) !== 'undefined') {
          this.context.apiKey = PLUCKIT_APIKEY;
        }
        // handle override template
        if (this.optionSpecified("templateId")) {
          this.template = document.getElementById(this.context.options.templateId).value;
        }
        this.requests = [];
        this.subWidgets = [];
        this.child = {};
        this.addChildWidgets();
        this.currentResponses = [];
        this.currentHTML = '';
        this.errorText = '';
        this.autoRender = true;
        this.templateAvail = false;
        // handle override template
        if (this.optionSpecified("remoteTemplateUrl")) {
          this.template = null;
          var me = this;
          this.downloadUrl(this.context.options.remoteTemplateUrl, null, function(template) {
            me.template = template;
          });
        } else if (this.optionSpecified("templateId")) {
          this.template = document.getElementById(this.context.options.templateId).value;
        }
        this.postInit();
      },
      buildTemplate: function() {
        if (this.templateAvail) return;
        this.template = this.getTemplate();
        this.template = this.template.replace(/WIDGETINSTANCE/gm, 'window[\'' + this.divId + '\']');
        
        var newSubwidgetsArray = new Array();
        for (var i = 0; i < this.subWidgets.length; i++) {
          var w = this.subWidgets[i];
          
          // if the template does not contain the subWidget, we remove it from the subWidgets array.
          if (this.template.indexOf("${" + w.instanceName + "}") != -1) {
            newSubwidgetsArray.push(w);
            w.buildTemplate();
            this.template = this.helper.replaceHTMLDivIds(this.template, w.instanceName, w.divId);
          }
          else if (pluckSlService.debugging.on && window.console) {
            console.log("widget " + this.instanceName + ": " + w.instanceName + " not found in template.  Removing from subwidgets");
          }
        }
        //Replace the original subwidgets array with the 
        this.subWidgets = newSubwidgetsArray;

        this.templateAvail = true;
      },
      downloadUrl: function(url, queryString, callback) {
        this.service.DownloadUrl(url, queryString, callback);
      },
      postForm: function(formUrl, queryString, callback) {
        this.service.PostForm(formUrl, queryString, callback);
      },
      sendRequests: function(requests, callback){
        var my = this;
        this.service.SendRequests(requests, function(batchResponse){
          if (batchResponse.hasOwnProperty('ContentTrackingJavaScript')) {
            my.helper.injectTrackingCode(batchResponse.ContentTrackingJavaScript, batchResponse.ContentTrackingSrc);
          }
          callback(batchResponse);
        });
      },
      showHtmlException: function(ex){
        this.currentHTML = this.helper.makeErrorSpan('[' + this.classname + ':' + this.instanceName + '] ' + ex.name + ': ' + ex.message);
        this.render();
      },
      errorHandler: function(ex) {
          // widgets can override this function for custom error handling
        this.showHtmlException(ex);
      },
      execute: function(callback, overrideOptions){
        try {
          // override existing options with passed in options
          if (typeof(overrideOptions) !== 'undefined') {
            this.helper.overrideOptions(this.context.options, overrideOptions);
          }
          
          this.clearRequests();
          
          var requests = this.getGlobalRequests();
          
          var me = this;
          this.sendRequests(requests, function(responseBatch){
            me.processGlobalResponses(responseBatch.Responses);
            me.finishExecuting(callback);
          });
        } catch (ex) {
          this.errorHandler(ex);
        }
      },        
      finishExecuting: function(callback){
        var my = this;
        try{
          my.clearRequests();
          var requests = my.getRequests();
          
          if (requests != null && requests.length > 0) {
            my.sendRequests(requests, function(batchResponse){
              try {
                my.waitForAllTemplates(function(all) {
                  if (all) {
                    my.buildTemplate();
                    var responses = batchResponse.Responses;
                    if (batchResponse.Messages) {
                        responses.Messages = batchResponse.Messages;
                    }
                    my.processResponses(responses);
                    my.finalizeContext();
                    if (my.autoRender) {
                      my.processTemplates();
                    }
                    if (typeof callback !== 'undefined') {
                      callback(my);
                    } else 
                    if (my.autoRender) {
                      my.render();
                    }
                  } else { // not all templates were loaded
                    my.showHtmlException({ name : 'Remote Templates', message : 'Not all remote templates could be downloaded' });
                  }
                });
              } catch (ex) {
                my.errorHandler(ex);
              }
            });
          } else {
            my.waitForAllTemplates(function(all) {
              if (all) {
                my.buildTemplate();
                // no content ... wait for div above to exist then fill content
                if (my.autoRender) {
                  my.processTemplates();
                }
                if (typeof callback !== 'undefined') {
                  callback(my);
                } else 
                if (my.autoRender) {
                  my.render();
                }
              } else { // not all templates were loaded
                my.showHtmlException({ name : 'Remote Templates', message : 'Not all remote templates could be downloaded' });
              }
            });
          }
        } catch (ex) {
          my.errorHandler(ex);
        }
      },
      hasAllTemplates: function() {
        if (this.template) {
          if (this.subWidgets.length > 0) {
            for (var i = 0; i < this.subWidgets.length; i++) {
              if (!this.subWidgets[i].hasAllTemplates()) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      },
      // we will wait around 10 seconds for templates
      waitForAllTemplates: function(callback) {
        var all = this.hasAllTemplates();
        if (all) {
          callback(true);
        } else {
          var retry = retry || 0;
          if (retry++ < 40) {
            var my = this; 
            setTimeout(function(){ my.waitForAllTemplates(callback, retry); }, 250 * retry);
          } else {
            callback(false);
          }
        }
      },
      render: function(retry){
          if (document.getElementById(this.divId) == null) {
              var dotimer = 0;
              if (typeof(retry) === 'undefined') {
                  dotimer = 1;
              }
              else if (retry < 10) {
                  dotimer = retry + 1;
              }
              if (dotimer > 0) {
                  if (pluckSlService.debugging.on && window.console) {
                      console.log(this.instanceName + ': render retry ' + dotimer);
                  }
                  var me = this;
                  setTimeout(function() {
                      me.render(dotimer);
                  }, 100 * dotimer);
              }
          }
          else {
              document.getElementById(this.divId).innerHTML = this.currentHTML;
              this.processPostRender();
          }
      },
      processPostRender: function(){
        if (this.subWidgets.length > 0) {
          for (var i = 0; i < this.subWidgets.length; i++) {
            this.subWidgets[i].processPostRender();
          }
        }
        if (typeof(this.postRender) === "function") {
          this.postRender();
        }
        this.fireEvent('onRendered');
        this.checkCompleted();        
      },
      checkCompleted: function() {
          // if this has fired before, then this is a re-render... just return
          if (this.completedFired) {
              return;
          }
          if (this.childWidgetsCompleted.length < this.subWidgets.length || !this.autoRender) {
              // either I haven't rendered or not all child widgets have completed, so don't fire completed event yet
              return;
          }
          if (pluckSlService.debugging.on && window.console) {
              console.log('widget ' + this.instanceName + ': ' + this.childWidgetsCompleted.length + ' child widgets completed loading');
          }
          this.completedFired = true;
          this.fireEventOnce('onCompleted');  
      },
      addChildWidget: function(classname, instanceName){
        var widget = this.creator.createWidget(this, classname, instanceName, null, this.context.options[instanceName], this.events[instanceName]);
        var me = this;
        widget.addEventCallback('onCompleted', function(eventInfo) {
            me.childWidgetsCompleted.push(true);
            me.checkCompleted();
        })
        this.subWidgets.push(widget);
        this.child[widget.instanceName] = widget;
      },
      addChildWidgetReplaceTemplate: function(classname, instanceName){
        var widget = this.creator.createWidget(this, classname, instanceName, null, this.context.options[instanceName]);
        var me = this;
        widget.addEventCallback('onCompleted', function(eventInfo) {
            me.childWidgetsCompleted.push(true);
            me.checkCompleted();
        })
        this.subWidgets.push(widget);
        this.child[widget.instanceName] = widget;
        widget.template = this.template;
        this.template = "${" + instanceName + "}";
      },
      getRequests: function(){
        this.requests = [];
        
        this.addRequests();
        var requests = this.requests;
        if (this.subWidgets.length > 0) {
          for (var i = 0; i < this.subWidgets.length; i++) {
            requests = requests.concat(this.subWidgets[i].getRequests());
          }
        }
        return requests;
      },
      clearRequests: function(){
        this.requests = [];
        if (this.subWidgets.length > 0) {
          for (var i = 0; i < this.subWidgets.length; i++) {
            this.subWidgets[i].clearRequests();
          }
        }
      },
      addRequest: function(request){
        if (typeof request != 'undefined') 
          this.requests.push(request);
      },
      processTemplate: function(){
        this.buildTemplate();
        if (this.errorText > '') {
          return this.helper.makeErrorSpan(this.errorText);
        } else {
          var tmpl = TrimPath.parseTemplate(this.template);
          if (tmpl != null) {
            var flags = {};
            flags.throwExceptions = true;
            try {
              return tmpl.process(this.context, flags);
            } catch (ex) {
              return this.helper.makeErrorSpan('[' + this.classname + ':' +
              this.instanceName +
              '] ' +
              ex.name +
              ': ' +
              ex.message);
            }
          } else {
            return this.helper.makeErrorSpan('[' + this.classname + ':' +
            this.instanceName +
            '] parseTemplate returned null');
          }
        }
      },
      multipleShift: function(array, number){
        var returned = [];
        for (var i = 0; i < number; i++) {
          returned.push(array.shift());
        }
        return returned;
      },
      getRequestsTreeLength: function(){
        var length = this.requests.length;
        for (var i = 0; i < this.subWidgets.length; i++) {
          length += this.subWidgets[i].getRequestsTreeLength();
        }
        return length;
      },
      processChildResponses: function(responses){
        if (this.subWidgets.length > 0) {
          for (var i = 0; i < this.subWidgets.length; i++) {
            if (this.subWidgets[i].requests.length > 0) {
              var subresponses = this.multipleShift(responses, this.subWidgets[i].getRequestsTreeLength());
              if (!this.helper.isArray(subresponses)) {
                subresponses = [subresponses];
              }
              this.subWidgets[i].processResponses(subresponses);
            }
            this.subWidgets[i].finalizeContext();
          }
        }
      },
      processResponses: function(responses){
        // make a local copy of the responses to save for later use in getResponseByType
        this.currentResponses = [];
        for (var i = 0; i < responses.length; i++) {
          this.currentResponses.push(responses[i]);
        };
        
        var _responses = null;
        if (this.requests.length > 0) {
          var _responses = this.multipleShift(responses, this.requests.length);
          if (!this.helper.isArray(_responses) && typeof(_responses) !== 'undefined') {
            _responses = [_responses];
          }
        }
        this.processChildResponses(responses);
        if (_responses != null) {
          this.buildContextFromResponses(_responses);
        }
      },
      processTemplates: function(){
        if (this.subWidgets.length > 0) {
          for (var i = 0; i < this.subWidgets.length; i++) {
            var htmldata = '';
            if (this.subWidgets[i].autoRender) {
              htmldata = this.subWidgets[i].processTemplates();
            }
            this.context[this.subWidgets[i].instanceName] = htmldata;
          }
        }
        this.currentHTML = this.processTemplate();
        return this.currentHTML;
      },
      optionSpecified: function(option){
        return (this.context.options && this.context.options.hasOwnProperty(option) && this.context.options[option]);
      },
      setRequestOption: function(request, option){
        if (this.optionSpecified(option)) {
          request[option] = this.context.options[option];
        }
      },
      setErrorText: function(text){
        this.errorText = '[' + this.classname + ':' + this.instanceName + '] ' + text;
      },
      appendErrorText: function(text){
        this.errorText = '  ' + text;
      },
      getResponseByType: function(responseType, index, askParents){
        if (typeof(index) === 'undefined') {
          index = 0;
          askParents = false;
        } else 
          if (typeof(askParents) === 'undefined') {
            askParents = false;
          }
        if (this.currentResponses && this.currentResponses.length > 0) {
          for (var i = 0; i < this.currentResponses.length; i++) {
            // our server response objects are declared as properties on objects, so...
            if (typeof(this.currentResponses[i]) !== 'undefined' && responseType in this.currentResponses[i]) {
              if (index == 0) {
                return this.currentResponses[i];
              } else {
                index--; // skip
                askParents = false; // found, so no longer consider parents
              }
            }
          }
        }
        if (typeof(askParents) !== 'undefined') {
          if (this.parent != null && askParents && typeof(this.parent.getResponseByType) === 'function') {
            return this.parent.getResponseByType(responseType, index, askParents);
          }
        }
        return null;
      },
      // Derived widgets only implement the following functions
      postInit: function(){
        // postInit is called after the init function is called
      },
      getTemplate: function(){
        // Call to get the template for this widget.
        return this.template;
      },
      addChildWidgets: function(){
        // Call addChildWidget for each child widget you have if applicable
      },
      addRequests: function(){
        // Add each data request you need
      },
      buildContextFromResponses: function(responses){
        // Set your context variables based on data requests responses
      },
      finalizeContext: function(){
        // last call to massage context data especially for composite widgets
      },
      postRender: function(){
        // called after each time you are rendered - any child widgets are called first
      },
      getGlobalRequests: function(){
        return [];
        // Allows for a request to be called at parent widget level.
      },
      processGlobalResponses: function(){
        // Handles responses from getGlobalRequests
      }
    };
  })();
}
if (typeof(PluckSlWidgetHelper) == 'undefined') {
  var PluckSlWidgetHelper = new PluckWidgetHelperBase();
  PluckSlWidgetHelper.extendObjectWith(PluckSlWidgetHelper, {
    focusField: function(elementId, focusColor){
      var elem = document.getElementById(elementId);
      if (!PluckSlWidgetHelper.formElementValuesSet[elementId]) {
        elem.value = "";
        if (focusColor) {
          elem.style.color = focusColor;
        }
      }
    },
    blurField: function(elementId, defaultValue){
      var elem = document.getElementById(elementId);
      if (!elem.value) {
        elem.value = defaultValue;
        // we're not preserving this form element value anymore
        delete PluckSlWidgetHelper.formElementValuesSet[elementId];
        // remove our color change
        elem.style.color = null;
      } else {
        // preserve this form element value
        PluckSlWidgetHelper.formElementValuesSet[elementId] = elem.value;
      }
    },
    getFieldValue: function(elementId){
      if (PluckSlWidgetHelper.formElementValuesSet[elementId]) {
        return PluckSlWidgetHelper.formElementValuesSet[elementId];
      } else {
        return null;
      }
    },
    // track which form elements have their values set
    formElementValuesSet: {},
    trim: function(stringToTrim) {
    	return stringToTrim.replace(/^\s+|\s+$/g,"");
    },
    ltrim: function(stringToTrim) {
    	return stringToTrim.replace(/^\s+/,"");
    },
    rtrim: function(stringToTrim) {
    	return stringToTrim.replace(/\s+$/,"");
    }
  });
}
if (typeof(PluckSlWidget) === 'undefined') {
  PluckSlWidget = function(){
    var widget = new PluckWidgetBase(PluckSlWidgetHelper);
    PluckSlWidgetHelper.extendObjectWith(widget, {
      processTemplates: function(){
        if (this.subWidgets.length > 0) {
          for (var i = 0; i < this.subWidgets.length; i++) {
            var htmldata = '<div id="' + this.subWidgets[i].divId +'">';
            if (this.subWidgets[i].autoRender) {
              htmldata += this.subWidgets[i].processTemplates();
            }
            htmldata += '</div>';
            this.context[this.subWidgets[i].instanceName] = htmldata;
          }
        }
        this.currentHTML = this.processTemplate();
        return this.currentHTML;
      }
    });
    return widget;
  }
  PluckSlWidget.createWidget = function(parent, classname, instanceName, divId, options, events){
    var widget = new window[classname];
    widget.creator = PluckSlWidget;
    widget.service = pluckSlService;
    widget.helper = PluckSlWidgetHelper;
    if (typeof(divId) === 'undefined' || divId == null) {
      divId = instanceName + '_' + PluckSlWidgetHelper.createUniqueId();
    }
    widget.divId = divId;
    widget.divSuffix = pluckSlService.uniqueID();
    widget.init(parent, classname, instanceName, options, events);
    window[widget.divId] = widget;
    return widget;
  }
  PluckSlWidget.runWidget = function(classname, widgetId, defaultOptions, options, events){
    if (!pluckSlService) {
      document.getElementById(widgetId).innerHTML = PluckSlWidgetHelper.makeErrorSpan("PluckSlService instance is null");
      return;
    }
    try {
      // consume default options
      if (!defaultOptions) {
        defaultOptions = PLUCKSL_WIDGET_OPTIONS_DEFAULT;
        PLUCKSL_WIDGET_OPTIONS_DEFAULT = null;
      }
      events = events || {};
      if (options) {          
        PluckSlWidgetHelper.overrideOptions(options, defaultOptions);
      } else 
        if (typeof(PLUCKSL_WIDGET_OPTIONS) != 'undefined' && PLUCKSL_WIDGET_OPTIONS != null) {
          PluckSlWidgetHelper.overrideOptions(PLUCKSL_WIDGET_OPTIONS, defaultOptions);
          PLUCKSL_WIDGET_OPTIONS = null;
        }
      PluckSlWidgetHelper.inheritOptions(defaultOptions, null);
      // create top widget
      var mainWidget = this.createWidget(null, classname, classname, widgetId, defaultOptions, events);
      mainWidget.execute();
    } catch (ex) {
      alert(ex.name + ' ' + ex.message);
      PluckSlWidgetHelper.makeErrorSpan('[' + widgetId + '] ' + ex.name + ': ' + ex.message);
    }
  }
}
if (typeof(slwidgets) === 'undefined') {
    slwidgets = {};
}

if (typeof(slwidgets.dateFormatMasks) === 'undefined') {	
	// Some common format strings
	slwidgets.dateFormatMasks = {
		"default":    "mm/dd/yyyy hh:MM:ss TT Z",
		shortDate:      "m/d/yy",
		mediumDate:     "mmm d, yyyy",
		longDate:       "mmmm d, yyyy",
		fullDate:       "dddd, mmmm d, yyyy",
		shortTime:      "h:MM TT",
		mediumTime:     "h:MM:ss TT",
		longTime:       "h:MM:ss TT Z",
		dashShortDate:  "m-d-yy",
		timeZone:		"Z",
		shortDateLongYear:	"m/d/yyyy",
		fullDayName:	"dddd",
		longMonthWithDay:	"mmmm d",
		paddedShortTime:	"hh:MM TT",
		paddedShortDate:	"m/dd/yy"
	};
}

if (typeof(slwidgets.dateFormatI18n) === 'undefined') {
	// Internationalization strings
	slwidgets.dateFormatI18n = {
    	dayNames: [
    		"Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat",
    		"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    	],
    	monthNames: [
    		"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    		"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
    	]
    };
}
	

if (typeof(slwidgets.dateFormat) === 'undefined') {

    slwidgets.pad = function (val, len) {
      val = String(val);
      len = len || 2;
      while (val.length < len) val = "0" + val;
      return val;
    };
    
    
    // server only date masks
    slwidgets.serverDateTimeFormatMask = {
    	slServer:     "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
    	isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
    	isoDate:        "yyyy-mm-dd",
		isoTime:        "HH:MM:ss",
		isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss"	
    };
    
    /*
     * Date Format 1.2.1
     * (c) 2007-2008 Steven Levithan <stevenlevithan.com>
     * MIT license
     * Includes enhancements by Scott Trenda <scott.trenda.net> and Kris Kowal <cixar.com/~kris.kowal/>
     *
     * Accepts a date, a mask, or a date and a mask.
     * Returns a formatted version of the given date.
     * The date defaults to the current date/time.
     * The mask defaults to dateFormat.masks.default.
     */
    slwidgets.dateFormat = function () {
    	var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
    		timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    		timezoneClip = /[^-+\dA-Z]/g;
    		
    	// Regexes and supporting functions are cached through closure
    	return function (date, mask, utc) {
    		var dF = slwidgets.dateFormat;
    		var slmasks = slwidgets;

    		// You can't provide utc if you skip other args (use the "UTC:" mask prefix)
    		if (arguments.length == 1 && (typeof date == "string" || date instanceof String) && !/\d/.test(date)) {
    			mask = date;
    			date = undefined;
    		}

    		// Passing date through Date applies Date.parse, if necessary
    		date = date ? new Date(date) : new Date();
    		if (isNaN(date)) throw new SyntaxError("invalid date");

    		//mask = String(dF.masks[mask] || mask || dF.masks["default"]);
    		mask = String(slmasks.dateFormatMasks[mask] || mask || slmasks.dateFormatMasks["default"] || slmasks.serverDateTimeFormatMask[masks]);

    		// Allow setting the utc argument via the mask
    		if (mask.slice(0, 4) == "UTC:") {
    			mask = mask.slice(4);
    			utc = true;
    		}

    		var	_ = utc ? "getUTC" : "get",
    			d = date[_ + "Date"](),
    			D = date[_ + "Day"](),
    			m = date[_ + "Month"](),
    			y = date[_ + "FullYear"](),
    			H = date[_ + "Hours"](),
    			M = date[_ + "Minutes"](),
    			s = date[_ + "Seconds"](),
    			L = date[_ + "Milliseconds"](),
    			o = utc ? 0 : date.getTimezoneOffset(),
    			flags = {
    				d:    d,
    				dd:   slwidgets.pad(d),
    				//ddd:  dF.i18n.dayNames[D],
    				//dddd: dF.i18n.dayNames[D + 7],
    				ddd:  slmasks.dateFormatI18n.dayNames[D],
    				dddd: slmasks.dateFormatI18n.dayNames[D + 7],
    				m:    m + 1,
    				mm:   slwidgets.pad(m + 1),
    				//mmm:  dF.i18n.monthNames[m],
    				//mmmm: dF.i18n.monthNames[m + 12],
    				mmm:  slmasks.dateFormatI18n.monthNames[m],
    				mmmm: slmasks.dateFormatI18n.monthNames[m + 12],
    				yy:   String(y).slice(2),
    				yyyy: y,
    				h:    H % 12 || 12,
    				hh:   slwidgets.pad(H % 12 || 12),
    				H:    H,
    				HH:   slwidgets.pad(H),
    				M:    M,
    				MM:   slwidgets.pad(M),
    				s:    s,
    				ss:   slwidgets.pad(s),
    				l:    slwidgets.pad(L, 3),
    				L:    slwidgets.pad(L > 99 ? Math.round(L / 10) : L),
    				t:    H < 12 ? "a"  : "p",
    				tt:   H < 12 ? "am" : "pm",
    				T:    H < 12 ? "A"  : "P",
    				TT:   H < 12 ? "AM" : "PM",
    				Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
    				o:    (o > 0 ? "-" : "+") + slwidgets.pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
    				S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    			};

    		return mask.replace(token, function ($0) {
    			return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
    		});
    	};
    }();
    
    slwidgets.toLocalTime = function(daapiTimeStr, systemTimeInfo){
      var combined = daapiTimeStr + " UTC" + (systemTimeInfo.ServerUTCOffset < 0 ? "-" : "+") + slwidgets.pad(Math.abs(systemTimeInfo.ServerUTCOffset), 2) + "00";
      return new Date(combined);
    };
    
    slwidgets.toLocalTimeString = function(daapiTimeStr, systemTimeInfo){
      return slwidgets.dateFormat(slwidgets.toLocalTime(daapiTimeStr, systemTimeInfo));
    };
}
if (!Array.prototype.indexOf)
{
  Array.prototype.indexOf = function(elt /*, from*/)
  {
    var len = this.length;

    var from = Number(arguments[1]) || 0;
    from = (from < 0)
         ? Math.ceil(from)
         : Math.floor(from);
    if (from < 0)
      from += len;

    for (; from < len; from++)
    {
      if (from in this &&
          this[from] === elt)
        return from;
    }
    return -1;
  };
}

if (typeof(slwidgets) === 'undefined') {
    slwidgets = {};
};
if (typeof(slwidgets.slWidgetBase) === 'undefined') {
    slwidgets.slWidgetBase = (function() {
		    
	
	    // initialize the number maps
	    var magnitudeName = [];
	    magnitudeName[0] = "byte";
	    magnitudeName[1] = "KB";
	    magnitudeName[2] = "MB";
	    magnitudeName[3] = "GB";
	
	    // initialize the name maps
	    var magnitudeDivisor = [];
	    magnitudeDivisor[0] = 1;
	    magnitudeDivisor[1] = 1024;
	    magnitudeDivisor[2] = 1024 * 1024;
	    magnitudeDivisor[3] = 1024 * 1024 * 1024;

    	
        return function() {

            // method to send requests and process templates that looks suspiciously like
            // slWidgetBase.finishExecuting. 
            // TODO: Merge this method and PluckWidgetHelperBase.finishExecuting.
            this.redraw = function(callback) {
                var me = this;
				var requests = this.buildRequests();
				if(requests.length) {
				  this.sendRequests(requests, function(responseBatch) {
					  me.buildContextFromResponses(responseBatch.Responses);
					  me.processTemplates();
					  if (me.autoRender) {
					      me.render();
					  }
					  if(typeof callback !== 'undefined'){
					    callback();
					  }
				  });
				}
				else {
					  me.processTemplates();
					  if (me.autoRender) {
					      me.render();
					  };
					  if(typeof callback !== 'undefined') {
					    callback();
					  }
				}
			}

            // support for events
            this.getEventInfo = function(forEventName) {
              if (!this.eventInfo) this.eventInfo = {};
              if (!this.eventInfo.hasOwnProperty(forEventName)) {
                this.eventInfo[forEventName] = { widget: this, name: forEventName, callbacks: [], fired: 0 };
              }
              return this.eventInfo[forEventName];
            }
            
            this.addEventCallback = function(eventName, callback) {
              this.getEventInfo(eventName).callbacks.push(callback);
            };
            
            this.fireEvent = function(eventName, eventArgs) {
              var event = this.getEventInfo(eventName);
              event.fired++;
              if (event.callbacks !== null) {
                  for (var i = 0; i < event.callbacks.length; i++) {
                      try {
                          event.callbacks[i](event, eventArgs);
                      } catch (e) {
                          if (pluckSlService.debugging.on && window.console) {
                                console.log('widget ' + this.instanceName + ': ' + eventName + ' error during callback ' + i + ' - ' + e.message);
                          }
                       }
                  }
              }
            };
            
            this.eventFired = function(eventName) {
              return this.getEventInfo(eventName).fired;
            };
            
            this.fireEventOnce = function(eventName, eventArgs) {
              
              if (this.eventFired(eventName) === 0) {
                this.fireEvent(eventName, eventArgs);
              }
            };
            
            this.userTiers = {
                'anonymous': 0,
                'standard' : 1,
                'trusted': 2,
                'featured': 3,
                'staff': 4,
                'sitemanager' : 5, /* portfolio */
                'editor': 6,
                'administrator' : 6 /* portfolio */
            }
            
            this.currentUserTierAtLeast = function(currentUser, userTier) {
                var userTierIndex = this.userTiers[currentUser.UserTier.toLowerCase()];
                var userAdminTierIndex = this.userTiers[currentUser.AdministrativeTier.toLowerCase()];
                return ((userTierIndex >= this.userTiers[userTier.toLowerCase()]) || (userAdminTierIndex >= this.userTiers[userTier.toLowerCase()]));
            };
            
            this.isLoggedIn = function(){
				return this.currentUserTierAtLeast(this.getCurrentUser(), 'standard');
            };
            
            this.getSystemTimeInfo = function(){
					if(this.systemTimeInfo) {
						return this.systemTimeInfo;
					}
					else if(this.parent) {
						return this.parent.getSystemTimeInfo();
					}
					else {
						return null;
					} 
				};
            
            this.toLocalTimeString = function(daapiTimeStr){
					return slwidgets.toLocalTimeString(daapiTimeStr, this.getSystemTimeInfo());
            };
            
            this.toLocalTime = function(daapiTimeStr){
					return slwidgets.toLocalTime(daapiTimeStr, this.getSystemTimeInfo());
            };

		this.convertDateToAgo = function(daapiTimeStr){
			var now = new Date();
			var d = this.toLocalTime(daapiTimeStr);

			if (now.getFullYear() == d.getFullYear()) {
				if (now.getMonth() == d.getMonth()) {
					if (now.getDate() == d.getDate()) {
						if (now.getHours() == d.getHours()) {
							var m = now.getMinutes() - d.getMinutes();
							if (m == 1) return "1 minute ago";
							else return m + " minutes ago";
						}
						else if (now.getHours() == d.getHours() + 1) {
							var m = now.getMinutes() - d.getMinutes() + 60;
							if (m == 1) return "1 minute ago";
							else if (m < 60) return m + " minutes ago";
							else return "1 hour ago";
						} else return (now.getHours() - d.getHours()) + " hours ago";
					}
					else if (now.getDate() == d.getDate() + 1) {
						var h = now.getHours() - d.getHours() + 24;
						if (h < 8) return h + " hours ago";
						else return "yesterday";
					}
					else if (now.getDate() == d.getDate() + 2) return "2 days ago";
					else {
						var dt = now.getDate() - d.getDate();
						if (dt < 7) {
							if (now.getDay() >= d.getDay()) return dt + " days ago";
							else return "last week";
						}
						else {
							var weeks = Math.ceil(dt / 7);
							if (now.getDay() > d.getDay()) weeks += 1;
							if (weeks == 1) return "last week";
							else return weeks + " weeks ago";
						}
					}
				}
				else if (now.getMonth() == d.getMonth() + 1) {
					var m = d.getMonth();
					var nd = 31;
					if (m == 3 || m == 5 || m == 8 || m == 10) nd = 30;
					else if (m == 1) nd = now.getFullYear() % 4 == 0 ? 29 : 28;
					var dt = now.getDate() + nd - d.getDate();
					if (dt < 7) {
						if (now.getDay() >= d.getDay()) {
							if (dt == 1) return "1 day ago";
							else return dt + " days ago";
						}
						else return "last week";
					}
					else if (dt < 14) {
						if (now.getDay() >= d.getDay()) return "last week";
						else return "last month";
					}
					else return "last month";
				}
				else return (now.getMonth() - d.getMonth()) + " months ago";
			}
			else if (now.getFullYear() == d.getFullYear() + 1) {
				var m = now.getMonth() - d.getMonth() + 12;
				return m <= 6 ? m + " months ago" : this.toLocalTimeString(daapiTimeStr).split(' ')[0];
			}
			else return this.toLocalTimeString(daapiTimeStr).split(' ')[0];
		};
            
            this.getCursorPos = function(event) {
            	var posx = 0;
            	var posy = 0;
            	event = event || window.event;
            	if (event.pageX || event.pageY) {
            		posx = event.pageX;
            		posy = event.pageY;
            	}
            	else if (event.clientX || event.clientY) 	{
            		posx = event.clientX + document.body.scrollLeft
            			+ document.documentElement.scrollLeft;
            		posy = event.clientY + document.body.scrollTop
            			+ document.documentElement.scrollTop;
            	}
            	return {
            	    'x': posx,
            	    'y': posy
            	};
            }
            
            this.postInit = function() {
                // only the top-level widget adds the default stylesheet
                if (!this.parent) {
                    if (this.context.options.useDefaultStylesheet) {
                        PluckSlWidgetHelper.addWidgetStylesheet(PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl +"content/widgets/css/groups.css");
                    }
                }
                if (this.context.options && !this.context.options.urls) {
                    // set the passed in urls object on the context for easy template use
                    this.context.options.urls = slwidgets.slUrls;
                }
                this.context.urls = this.context.options.urls;
                
                // add the top-level style to every widget
                var divElem = document.getElementById(this.divId);
                if (divElem) {
                    divElem.className = "slV2";
                }
                // add the showReportAbuseLink function to the context for widgets to use
                var me = this;
                this.context.showReportAbuse = function(keyType, keyId, abuseReported) {
                    return me.showReportAbuse(keyType, keyId, abuseReported);
                };
                // add the showRecommend function to the context for widgets to use
                this.context.showRecommend = function(keyType, keyId, recommended, numberOfRecommendations) {
                    return me.showRecommend(keyType, keyId, recommended, numberOfRecommendations);
                };
                this.context.getCurrentUser = function(){
                    return me.getCurrentUser();
                };
                this.context.isBozo = function(user){
                    return me.isBozo(user);
                };
                this.context.toLocalTimeString = function(daapiTimeStr){
							    return me.toLocalTimeString(daapiTimeStr);
                };
                this.context.toLocalTime = function(daapiTimeStr){
							    return me.toLocalTime(daapiTimeStr);
                };
                this.context.currentUserCanDelete = function(ownerKey, group) {
                    return me.currentUserCanDelete(ownerKey, group);
                };
                this.context.currentUserIsOwner = function(ownerKey) {
                    return me.currentUserIsOwner(ownerKey);
                };
				this.context.createErrorMessageId = function(errorId){
					return me.createErrorMessageId(errorId);
				};
				this.context.createNotificationId = function(notifId){
					return me.createNotificationId(notifId);
				};
				this.context.isLoggedIn = function(){
					return me.isLoggedIn();
				};
				
                // add the truncateDescription funtion to the context for widgets to use
                this.context.truncateString = function(str, len) {
					var trunc = str || '';
					// trim any white space that may be at the beginning or ending of the string.
					trunc = trunc.replace(/^\s+|\s+$/g, '');
					if (trunc.length > len) {
						// truncate the description content or any long text, then go back to the end of the 
						// previous word to ensure we don't truncate in the middle of the word. Include entity chars.
						trunc = trunc.substring(0, len);
						var lastSpace = trunc.lastIndexOf(" ");
						if(lastSpace > 0){
							trunc = trunc.substring(0, lastSpace);
						}
						
						// add an ellipses to the end
						trunc += '...';
							
						// if we truncated too much and are only left with ellipsis, then brute force it
						if (trunc.length === 3) {
							trunc = (str || '').substring(0, len - 3) + '...';
						}
					}
					return trunc;
				};
		
				this.context.truncateWord = function(str, len) {
					var trunc = str || '';
					// trim any white space that may be at the beginning or ending of the string.
					trunc = trunc.replace(/^\s+|\s+$/g, '');
					var words = trunc.split(" ");
					
					for (i=0; i<words.length; i++) {
						if (words[i].length > len) {
							// truncate any word that is abnormally long and can possibly screw with page layout. 
							words[i] = words[i].substring(0, len);
						
							// add an ellipses to the end
							words[i] += '...';
							
						}
						
					}
					var newString = words.join(" ");
					return newString;
				}
				
				// strip out any html tags from incoming string
				this.context.removeHTMLTags = function(htmlString) {
					var mydiv = document.createElement("div");
					
					var orig = htmlString;
				    var stripped = "";
				    var counter = 0;
				    var matchTag = /<(?:.|\s)*?>/g;
				    
					while(orig != stripped && counter < 5){
						stripped = orig.replace(matchTag, " ");
						
						orig = stripped;
						counter++;
				    }
				    
				    return stripped.replace(/[ ]+/, " ");
				};
				
				this.context.humanizeSizeString = function(sizeInBytes){

				    var magnitude = (Math.log(sizeInBytes))/(Math.log(2));
					var magnitudeIndex = Math.floor(magnitude/10);
				    var humanizedNum = sizeInBytes / magnitudeDivisor[magnitudeIndex];
				    var humanizedSizeName = magnitudeName[magnitudeIndex];				    
				    // pluralize the "byte" special case
				    if (magnitude == 0 && humanizedNum != 1){
				    	humanizedSizeName.Append("s");
				    } 				
				    return Math.round(humanizedNum) + humanizedSizeName;
				};
				
				this.context.stripHtml = function (item) {
					return item.replace(/(<([^>]+)>)/ig,"");
				};
        
              this.fireEventOnce('onLoaded');          
            }
            
            this.isPrivateGroup = function(group){
                return group.CommunityGroupVisibility.toLowerCase() != "public";
            };
            
            this.currentUserIsGroupAdmin = function(group){
                return group.RequestingUsersMembershipTier == "GroupAdmin";
            };
            
            this.currentUserIsGroupManager = function(group){
                return group.RequestingUsersMembershipTier == "Manager" || this.currentUserIsGroupAdmin(group);
            };
            
            this.currentUserIsGroupMember = function(group){
                return group.RequestingUsersMembershipTier == "Member" || this.currentUserIsGroupManager(group);
            };
            
            this.currentUserIsBannedFromGroup = function(group){
                return group.RequestingUsersMembershipTier == "Banned";
            };
            
            this.currentUserCanDelete = function(ownerKey, group) {
                return this.getCurrentUser().UserKey.Key === ownerKey.Key || this.currentUserIsGroupManager(group);
            };
            
            this.currentUserIsOwner = function(ownerKey) {
                return this.getCurrentUser().UserKey.Key === ownerKey.Key;
            };
                        
            
            this.rerender = function() {
                this.autoRender = true;
                this.processTemplates();
                this.render();
            };
            
            this.showReportAbuse = function(keyType, keyId, abuseReported) {
                if (typeof(slReportAbuseWidget) === 'undefined') {
                    alert('You must include the report abuse widget as a child widget before calling this function.');
                    return;
                }
                if (typeof(slReportAbuseDialogWidget) === 'undefined') {
                    alert('You must include the report abuse dialog widget as a child widget before calling this function.');
                    return;
                }
                if (typeof(this.reportAbuseDialog) === 'undefined') {
                    alert('You must set this.reportAbuseDialog to the instance of the report abuse dialog before calling this function.');
                    return;
                }
                var reportAbuseId = PluckSlWidgetHelper.createUniqueId('reportAbuse');
                var anonymousUserToReportAbuse = (PLUCKSL_GLOBAL_OPTIONS["anonymousUserToReportAbuse"] == "True") ? true : false;
            	
                // we'll return the rendered report abuse widget in a div
                var resultHtml = '<div id="' + reportAbuseId + '">'
                // save this for the callback
                var me = this;
                abuseReported = abuseReported || false;
                var reportAbuseOptions = {
                    'reportAbuseClicked': function(event, callbackKeyType, callbackKeyId, reportedCallback) {
                        return me.onReportAbuse(event, callbackKeyType, callbackKeyId, reportedCallback)
                    },
                    'keyType': keyType,
                    'keyId': keyId,
                    'abuseReported': abuseReported,
                    'anonymousUserCanReportAbuse': anonymousUserToReportAbuse
                };
                // pass in the report abuse template id if we were given one
                if (this.optionSpecified('reportAbuseTemplateId')) {
                    reportAbuseOptions['templateId'] = this.context.options['reportAbuseTemplateId'];
                }
                var reportAbuseWidget = PluckSlWidget.createWidget(this, 'slReportAbuseWidget', reportAbuseId, 
                    reportAbuseId, reportAbuseOptions);
                reportAbuseWidget.buildTemplate();
                // render the report abuse widget
                resultHtml += reportAbuseWidget.processTemplates();
                resultHtml += '</div>';
                return resultHtml;
            };

            this.addConfirmationBoxAsChild = function(){
                this.addChildWidget('slMessageBox', 'confirmationBox');
            };            
            
            this.showConfirmation = function(message, confirmedCallback, cancelCallback) {
                if (typeof(this.child['confirmationBox']) == 'undefined'){
                    alert("You must include the confirmationBox widget in order to use showConfirmation");
                    return;
                }
                var messageElement = document.getElementById(message);
                var messageText = message;
                if (typeof(messageElement) != 'undefined'){
                    messageText = messageElement.value ? messageElement.value : messageElement.innerHtml;
                }
                var me = this;
                this.child['confirmationBox'].setDialogMessage(messageText);
                this.hideAllFlash();
                this.child['confirmationBox'].show(function() {
                    me.showAllFlash();
                    if (confirmedCallback) {
                        confirmedCallback();
                    }
                }, function() {
                    me.showAllFlash();
                    if (cancelCallback) {
                        cancelCallback();
                    }
                })
            };
            
            this.onReportAbuse = function(event, keyType, keyId, reportedCallback) {
                this.reportAbuseDialog.context.options.success = function() {
                    reportedCallback();
                };
                // default behavior of hiding dialog is good enough; do nothing else
                this.reportAbuseDialog.context.options.cancel = function() {};
                var cursorPos;
                // For IE, if zoom is set on a parent, it becomes a positioned element. Cannot use cursorPos for this reason.
               	var isIE = /*@cc_on!@*/false;
                if (isIE) {
                    cursorPos = { x: 0, y: 0 };
                    var element = event.srcElement;
                    do {
                        cursorPos.y += element.offsetTop  || 0;
                        cursorPos.x += element.offsetLeft || 0;
                        element = element.offsetParent;
                        if (element) {
                            if (element.tagName == 'BODY') break;
                            var p = element.style.position;
                            if (p == 'relative' || p == 'absolute') break;
                            if (element.className.indexOf("slContent") != -1) break;
                        }
                    } while (element);
                    cursorPos.y += 20;
                } else {
                    cursorPos = this.getCursorPos(event);
                }
                this.reportAbuseDialog.show(cursorPos.x, cursorPos.y, keyType, keyId);
            };
            
            this.showRecommend = function(keyType, keyId, recommended, numberOfRecommendations) {
                if (typeof(slRecommendWidget) === 'undefined') {
                    alert('You must include the report abuse widget as a child widget before calling this function.');
                    return;
                }
                var recommendId = PluckSlWidgetHelper.createUniqueId('recommend');
                // we'll return the rendered recommend widget in a div
                var resultHtml = '<div id="' + recommendId + '">'
                // save this for the callback
                var me = this;
                recommended = recommended || false;
            	numberOfRecommendations = numberOfRecommendations || '0';
            	var recommendOptions = {
            	    'recommendClicked': function(event, callbackKeyType, callbackKeyId, recommendCallback) {
            	        return me.onRecommend(event, callbackKeyType, callbackKeyId, recommendCallback)
            	    },
            	    'keyType': keyType,
            	    'keyId': keyId,
            	    'recommended': recommended,
            	    'numberOfRecommendations': numberOfRecommendations
            	};
            	// pass in the recommend template id if we were given one
            	if (this.optionSpecified('recommendTemplateId')) {
            	    recommendOptions['templateId'] = this.context.options['recommendTemplateId'];
            	}
            	var recommendWidget = PluckSlWidget.createWidget(this, 'slRecommendWidget', recommendId, 
            	    recommendId, recommendOptions);
            	recommendWidget.buildTemplate();
            	if (!this.getCurrentUser().isAnonymous) {	
                	// render the report abuse widget
                	resultHtml += recommendWidget.processTemplates();	
                }
                resultHtml += '</div>';
                return resultHtml;
            };
            
            this.onRecommend = function(event, keyType, keyId, recommendedCallback) {
                var key = this.createDaapiKey(keyType, keyId);
                var recommendAction = new RecommendAction(key);
                this.sendRequests([recommendAction], function(batchResponse) {
                });
                recommendedCallback();
            };
            
            this.createDaapiKey = function(keyTypeString, keyId) {
                var keyType = window[keyTypeString];
                // create a new instance through the Object.beget pattern
                var keyCtor = function() {
                    this.initialize.apply(this, arguments);
                };
                keyCtor.prototype = keyType.prototype;
                var key = new keyCtor(keyId);
                return key;
            };

            
            this.formatUrl = function(url) {
				if(!url){
					url = "";
				}
				// concatenate http:// to the url string
				var prefixUrl = /(\w+):/;
				var matchResults = url.match(prefixUrl);
				if (!matchResults) {
					fullurl = "http://" + url;
				} else {
					fullurl = url;
				}
				return fullurl;
			};
            
            this.getCurrentUser = function(){
              if(this.currentUser)
                return this.currentUser;
              else if(this.parent)
                return this.parent.getCurrentUser();
              else
                return null;
            };
                      
            this.getGlobalRequests = function(){
              var requests =[];
              // Fetch the current user
              requests.push(new UserKey());
              requests.push(new SystemTimeInfo());
              
              return requests;
            };
                   
            this.processGlobalResponses = function(responses){
              for(i=0; i<responses.length; i++){
                if(!this.currentUser && responses[i].User){
                  this.currentUser = responses[i].User;
                  this.currentUser.isAnonymous = this.currentUser.UserTier === "Anonymous";
                }
                
                if(!this.systemTimeInfo && responses[i].SystemTimeInfo){
						this.systemTimeInfo = responses[i].SystemTimeInfo;
                }
              }
            };
            
            this.isBozo = function(targetUser) {
              return ((targetUser.IsBlocked.toLowerCase() == 'true') && (targetUser.UserKey.Key != this.context.getCurrentUser().UserKey.Key));
            };
            
            this.validateAddress = function(emailAddress){
				var emailstring = emailAddress;
				var ampIndex = emailstring.indexOf("@");
				var afterAmp = emailstring.substring((ampIndex + 1), emailstring.length);
	
				// find a dot in the portion of the string after the ampersand only
				var dotIndex = afterAmp.indexOf(".");
	
				// determine dot position in entire string (not just after amp portion)
				dotIndex = dotIndex + ampIndex + 1;
	
				// afterAmp will be portion of string from ampersand to dot
				afterAmp = emailstring.substring((ampIndex + 1), dotIndex);
	
				// afterDot will be portion of string from dot to end of string
				var afterDot = emailstring.substring((dotIndex + 1), emailstring.length);
				var beforeAmp = emailstring.substring(0,(ampIndex));

				var email_regex = /^\w(?:\w|-|\.(?!\.|@))*@\w(?:\w|-|\.(?!\.))*\.\w{2,3}/ 
				// index of -1 means "not found"
				if ((emailstring.indexOf("@") != "-1") &&
					(emailstring.length > 5) &&
					(afterAmp.length > 0) &&
					(beforeAmp.length > 1) &&
					(afterDot.length > 1) &&
					(email_regex.test(emailstring)) ) {
					  return true;
				} else {
					return false;
				}
			};
            
            // Error handling helpers
            this.errorMessages = {};
            
            this.createErrorMessageId = function(errorId){
				// Create a unique ID, then add it to the array.
				this.errorMessages[errorId] = PluckSlWidgetHelper.createUniqueId('error_' + errorId + '_');
				return this.errorMessages[errorId];
            };
            
            this.clearErrorMessages = function(){
				if(this.errorMessages){
					for(messageId in this.errorMessages){
						var errorDiv = document.getElementById(this.errorMessages[messageId]);
						if(errorDiv){
							errorDiv.style.display = "none";
						}	
					}
				}
            };
            
			this.showErrorMessage = function(errorId, messagesFromDaapi){
				// If custom error handler exists, call it.
				// If it returns true, keep going on with our own handling.  Else return
				if (this.context.options.slCustomErrorHandler && 
					this.context.options.slCustomErrorHandler(errorId, messagesFromDaapi)){
					return false;
				}
				
				if (messagesFromDaapi){
					var messageText = "";
					for(i=0; i<messagesFromDaapi.length; i++){
						messageText += messagesFromDaapi[i].Message +'\n';
					}
					
					alert("Error: " + messageText);
				}
				
				var errorDiv = document.getElementById(this.errorMessages[errorId]);
				if(errorDiv){
					errorDiv.style.display = "block";
				}
				
				return false;
			};
			
			// Treat notifications just like errors.  Only difference is the classname applied to the elements.
			this.createNotificationId = function(notifId){
				return this.createErrorMessageId(notifId);
			};
			
			this.clearNotifications = function(){
				this.clearErrorMessages();
			};
			
			this.showNotification = function(notifId){
				return this.showErrorMessage(notifId);
			};
			
			this.validateNotEmpty = function(inputId, errorId){
				var theField = document.getElementById(inputId);
				if(theField){
					var theValue = PluckSlWidgetHelper.trim(theField.value);
					if (theValue && theValue != "") {
						return true;
					}	
				}				
				
				this.showErrorMessage(errorId);
				return false;
			};
			
			this.isDirtyWordError = function(message){
				return (message.toLowerCase().indexOf("words not permitted") >= 0);
			};
			
			this.isFloodControlError = function(message){
				if(message.toLowerCase().indexOf('restrict rapid') >= 0){
					return true;
				}
				if(message.toLowerCase().indexOf('limit the number of') >= 0){
					return true;
				}
				
				return false;
			};
			
			this.parseDirtyWordError = function(message){
				if(!this.isDirtyWordError(message)){
					return [];
				}
				
				var forExampleText = "for example: ";
				var startPos = message.lastIndexOf(forExampleText) + forExampleText.length;
				
				// Get just the comma separated list.  String ends with ").", so -2 on the length.
				var stringList = message.substring(startPos, message.length - 2);
				
				return stringList.split(', ');
			};
			
			this.htmlEncode = function(str){
				// Fix HTML
				var ret = str;
				var div = document.createElement('div');
				var text = document.createTextNode(str);
				div.appendChild(text);
				ret = new String(div.innerHTML);				
				
				// The above doesn't take care of quotes.
				ret = ret.replace(/"/g, '&quot;');
				
				return ret;
			};

			this.hideAllFlash = function() {
		        this.flashElements = [];
		        this.flashStyles = [];
		        // grab object and embed elements and hide them all
		        var objTags = document.getElementsByTagName('object');
		        for (var objIndex = 0; objIndex < objTags.length; objIndex++) {
		        	if (objTags[objIndex].clientWidth > 1 && objTags[objIndex].clientHeight > 1) {
		            	this.flashElements.push(objTags[objIndex]);
	            	}
		        }
		        var embedTags = document.getElementsByTagName('embed');
		        for (var embedIndex = 0; embedIndex < embedTags.length; embedIndex++) {
		        	if (embedTags[embedIndex].clientWidth > 1 && embedTags[embedIndex].clientHeight > 1) {
		            	this.flashElements.push(embedTags[embedIndex]);
	            	}
		        };
		        // set the css of each of those elements to visibility: hidden
		        for (var flashIndex=0; flashIndex < this.flashElements.length; flashIndex++) {
		            this.flashStyles.push(this.flashElements[flashIndex].style.visibility);
		            this.flashElements[flashIndex].style.visibility = 'hidden';
		        };
		        
		    };
		    
		    this.showAllFlash = function() {
		        if (this.flashElements && this.flashStyles) {
		            for (var flashIndex=0; flashIndex < this.flashElements.length; flashIndex++) {
		                this.flashElements[flashIndex].style.visibility = this.flashStyles[flashIndex];
		            };
		        }
		    };
		    

			this.makeCommentLink = function(comment) {
				if(comment.CommentedOnType == "BlogPost"){
					return this.context.urls.groups.showBlogPost(this.context.currentGroup.CommunityGroupKey.Key, this.context.currentGroup.BlogKey.Key, comment.CommentedOnKey, comment.CommentKey.Key);
				}
				else if (comment.CommentedOnType == "Photo"){
					return this.context.urls.groups.showPhoto(this.context.currentGroup.CommunityGroupKey.Key, this.context.currentGroup.PhotoGalleryKey.Key, comment.CommentedOnKey, 0, comment.CommentKey.Key);
				}
				else if (comment.CommentedOnType == "Video"){
					return this.context.urls.groups.showVideo(this.context.currentGroup.CommunityGroupKey.Key, this.context.currentGroup.VideoGalleryKey.Key, comment.CommentedOnKey, 0, comment.CommentKey.Key);
				}
				else {
					return null;
				}
			};
			
        }
    })();
}
// base class of slWidgetBase is PluckSlWidget
slwidgets.slWidgetBase.prototype = new PluckSlWidget();
if (typeof(slwidgets) === 'undefined') {
    slwidgets = {};
}
if (typeof(slwidgets.slPagingWidgetBase) === 'undefined') {
    slwidgets.slPagingWidgetBase = (function() {
        
        return function() {
			
			// updateWidgetUrl is used to load a new url with an updated onPage value.  Fix for SLS-5048.
			this.updateWidgetUrl = function(onPage) {
				if (typeof(this.buildPaginationUrl) !== 'undefined') {
					// method is defined in the widget that is utilizing pagination
					this.buildPaginationUrl(onPage);
				}
				else {
					// Don't have to build a new Url.
					return;
				}
			}
			
			this.setPaginationState = function(totalNumber, onPage, numberPerPage) {
			    this.context.paginationVars = slwidgets.slPagingWidgetBase.createPaginationTemplateParams(totalNumber, onPage, numberPerPage);
			};
            
            this.firstPage = function() {
				this.context.onPage = this.context.paginationVars.firstPageNum;
				this.updateWidgetUrl(this.context.onPage);
				this.redraw();
				return false;
			}
			
			this.prevPage = function() {
				this.context.onPage = this.context.paginationVars.prevPageNum;
				this.updateWidgetUrl(this.context.onPage);
				this.redraw();
				return false;
			}
			
			this.lastPage = function() {
				this.context.onPage = this.context.paginationVars.lastPageNum;
				this.updateWidgetUrl(this.context.onPage);
				this.redraw();
				return false;
			}
			
			this.nextPage = function() {
				this.context.onPage = this.context.paginationVars.nextPageNum;
				this.updateWidgetUrl(this.context.onPage);
				this.redraw();
				return false;
			}
			
			this.gotoPage = function(onPage) {
				this.context.onPage = onPage;
				this.updateWidgetUrl(this.context.onPage);
				this.redraw();
				return false;
			}
            
        };
    })();
}
// base class of slPagingWidgetBase is slWidgetBase
slwidgets.slPagingWidgetBase.prototype = new slwidgets.slWidgetBase();
// encase static functions in scope to prevent global namespace pollution of stray vars
(function() {
    slwidgets.slPagingWidgetBase.createPaginationTemplateParams = function(totalItems, onPage, numberPerPage) {
        // creates a one-based set of params used to display pagination links.
        var first = prev = next = lastPage = null;
        // only paginate if there are items to paginate with
        if (totalItems > 0) {
            // force numberPerPage and onPage to a number
            var numPerPage = numberPerPage - 0;
            var numOnPage = onPage - 0;
            lastPage = Math.floor(totalItems / numPerPage) + (totalItems % numPerPage == 0 ? 0 : 1);
            if (numOnPage != 1) {
                first = 1;
                prev = numOnPage - 1;
            }
            if (numOnPage != lastPage) {
                next = numOnPage + 1;
            } else {
                // don't return a last page if we're on the last page
                lastPage = null;
            }
        }
        
        return {
            "firstPageNum": first,
            "prevPageNum": prev,
            "nextPageNum": next,
            "lastPageNum": lastPage
        };
    }
})();if (typeof(slwidgets) === 'undefined') {
    slwidgets = {};
};
if (typeof(slwidgets.slPrivateMessagingWidgetBase) === 'undefined') {
    slwidgets.slPrivateMessagingWidgetBase = (function() {
		return function() {
			this.isMaxRecipientsError = function(message){
				return (message.toLowerCase().indexOf("many recipients") >= 0);
			};
		}
    })();
}
// base class of slWidgetBase is PluckSlWidget
slwidgets.slPrivateMessagingWidgetBase.prototype = new slwidgets.slWidgetBase();
if (typeof(slwidgets) === 'undefined') {
    slwidgets = {};
}
if (typeof(slwidgets.slPrivateMessagingPagingWidgetBase) === 'undefined') {
    slwidgets.slPrivateMessagingPagingWidgetBase = (function() {
        
        return function() {
            
            this.redraw = function(callback) {
				var requests = this.buildRequests();
				var my = this;
				if(requests.length){
				  this.sendRequests(requests, function(responseBatch) {
					  my.buildContextFromResponses(responseBatch.Responses);
					  my.processTemplates();
					  if (my.autoRender) {
					      my.render();
					  }
					  if(typeof callback !== 'undefined'){
					    callback();
					  }
				  });
				}
				else{
					  my.processTemplates();
					  if (my.autoRender) {
					      my.render();
					  };
					  if(typeof callback !== 'undefined'){
					    callback();
					  }
				}
			}
			
			this.setPaginationState = function(totalNumber, onPage, numberPerPage) {
			    this.context.paginationVars = slwidgets.slPrivateMessagingPagingWidgetBase.createPaginationTemplateParams(totalNumber, onPage, numberPerPage);
			};
            
            this.firstPage = function() {
				this.context.onPage = this.context.paginationVars.firstPageNum;
				this.redraw();
			}
			
			this.prevPage = function() {
				this.context.onPage = this.context.paginationVars.prevPageNum;
				this.redraw();
			}
			
			this.lastPage = function() {
				this.context.onPage = this.context.paginationVars.lastPageNum;
				this.redraw();
			}
			
			this.nextPage = function() {
				this.context.onPage = this.context.paginationVars.nextPageNum;
				this.redraw();
			}
            
        };
    })();
}
// base class of slPagingWidgetBase is slWidgetBase
slwidgets.slPrivateMessagingPagingWidgetBase.prototype = new slwidgets.slPrivateMessagingWidgetBase();
// encase static functions in scope to prevent global namespace pollution of stray vars
(function() {
    slwidgets.slPrivateMessagingPagingWidgetBase.createPaginationTemplateParams = function(totalItems, onPage, numberPerPage) {
        // creates a one-based set of params used to display pagination links.
        var first = prev = next = lastPage = null;
        // only paginate if there are items to paginate with
        if (totalItems > 0) {
            // force numberPerPage and onPage to a number
            var numPerPage = numberPerPage - 0;
            var numOnPage = onPage - 0;
            lastPage = Math.floor(totalItems / numPerPage) + (totalItems % numPerPage == 0 ? 0 : 1);
            if (numOnPage != 1) {
                first = 1;
                prev = numOnPage - 1;
            }
            if (numOnPage != lastPage) {
                next = numOnPage + 1;
            } else {
                // don't return a last page if we're on the last page
                lastPage = null;
            }
        }
        
        return {
            "firstPageNum": first,
            "prevPageNum": prev,
            "nextPageNum": next,
            "lastPageNum": lastPage
        };
    }
})();
if (typeof(slwidgets.slUtils) === 'undefined') {
    slwidgets.slUtils = (function() {
        return {
            "createPaginationTemplateParams": function(totalItems, onPage, numberPerPage) {
                // creates a one-based set of params used to display pagination links.
                var first = prev = next = lastPage = null;
                // only paginate if there are items to paginate with
                if (totalItems > 0) {
                    // force numberPerPage and onPage to a number
                    var numPerPage = numberPerPage - 0;
                    var numOnPage = onPage - 0;
                    lastPage = Math.floor(totalItems / numPerPage) + (totalItems % numPerPage == 0 ? 0 : 1);
                    if (numOnPage != 1) {
                        first = 1;
                        prev = numOnPage - 1;
                    }
                    if (numOnPage != lastPage) {
                        next = numOnPage + 1;
                    } else {
                        // don't return a last page if we're on the last page
                        lastPage = null;
                    }
                }
                return {
                    "firstPageNum": first,
                    "prevPageNum": prev,
                    "nextPageNum": next,
                    "lastPage": lastPage
                };
            }
            ,"buildUrl": function(base, page, qs, anchor) {
            	var url = "" + base;
            	if(page){
					if (url.indexOf("?") != -1) {
						url += "&slPage="+encodeURIComponent(page);
					}
					else {
						url += "?slPage="+encodeURIComponent(page);
					}
                }
                if (qs) {
                    for(var key in qs) {
						if(url.indexOf("?") != -1){
							url += "&";
						}   
						else{
							url += "?";
						}
                        url += key+"="+encodeURIComponent(qs[key]);
                    }
                }
                if (anchor) {
                    url += '#' + encodeURIComponent(anchor);
                }
                // strip any duplicate slashes except from http://
                url = url.replace(/(\w)\/\//g, '$1/');
                return url;
            }
        }
    })();
}if (typeof slwidgets.slUrls === 'undefined') {
    slwidgets.slUrls = (function() {
        var buildGroupsUrl = function(checkTearOff, page, queryString, anchorString) {
            if (typeof(CMWBaseUrl) === 'undefined') {
                if (checkTearOff && typeof(SLTearOffBaseUrl) !== 'undefined')
                    return slwidgets.slUtils.buildUrl(SLTearOffBaseUrl, page, queryString, anchorString);
                else
                    return slwidgets.slUtils.buildUrl(combinePath(PLUCKSL_GLOBAL_OPTIONS.baseUrl, PLUCKSL_GLOBAL_OPTIONS.groupsSuffix), page, queryString, anchorString);
            }
            else {
                return slwidgets.slUtils.buildUrl(CMWBaseUrl, page, queryString, anchorString);
            }
        };
        
		var buildPrivateMessagingUrl = function(page, queryString) {
			return slwidgets.slUtils.buildUrl(combinePath(PLUCKSL_GLOBAL_OPTIONS.baseUrl, PLUCKSL_GLOBAL_OPTIONS.privateMessagingSuffix), page, queryString);
		};
        
        // if a string is null or undefined, returns an empty string
        var safeString = function(str) {
            return str ? str : '';
        };
        
        // "http://www.foo.com/" + "/pants" should be "http://www.foo.com/pants", not "http://www.foo.com//pants"
        // (one slash instead of two).
        var combinePath = function(domain, path){
			if(domain[domain.length-1] == '/' && path[0] == '/'){
				path = path.substr(1);
			}
			
			return domain + path;
        };
        
        return {
            'daapi': function() {
                return combinePath(PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl, 'Direct/Process');
            }
            ,'groups': {
                'groupList': function(search, groupNotFound) {
                    if (typeof(groupNotFound) === 'undefined') {
                        groupNotFound = false;
                    }
                    return buildGroupsUrl(false, '', {
                        'slSearchString': safeString(search),
                        'slGroupNotFound': '' + groupNotFound
                    });
                }
                ,'overview': function(groupKey, forcePublic, acceptInvitation) {
                    var queryString = {
                        'slGroupKey': groupKey,
                        'slAcceptInvitation' : acceptInvitation ? acceptInvitation : false
                    };
                    // if force public, don't give back CMW overview url
                    if (forcePublic) {
                        return slwidgets.slUtils.buildUrl(combinePath(PLUCKSL_GLOBAL_OPTIONS.baseUrl, PLUCKSL_GLOBAL_OPTIONS.groupsSuffix), 
                            'overview', queryString);
                    }
                    else {
                        return buildGroupsUrl(true, 'overview', queryString);
                    }
                }
                ,'search': function(searchType, searchTerm, groupKey) {
                    return buildGroupsUrl(true, 'searchResults', {
                        'slGroupKey': safeString(groupKey),
                        'slSearchString': searchTerm,
                        'slSearchType': searchType
                    });
                }
                ,'updateGroup': function(groupKey, cancelUrl) {
                    // default to current location if cancelUrl not given
                    var queryString = { 
                        'slGroupKey': safeString(groupKey),
                        'slCancelUrl' : cancelUrl ? cancelUrl : window.location.href
                    };
                    return buildGroupsUrl(false, 'updateGroup', queryString);
                }
                ,'rss': function(groupKey) {
                    return combinePath(PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl, 'CommunityGroups/Rss?slGroupKey=' + groupKey);
                }
                ,'manageMembers': function(groupKey, search) {
                    var queryString = {
                        'slGroupKey': groupKey,
                        'slSearchString': safeString(search)
                    };
                    return buildGroupsUrl(false, 'manageMembers', queryString);
                }
                ,'updateLink': function(groupKey, cancelUrl, linkKey) {
                	// default to current location if cancelUrl not given
                    var queryString = {
                        'slGroupKey': safeString(groupKey),
                        'slLinkKey': safeString(linkKey),
                        'slCancelUrl' : cancelUrl ? cancelUrl : window.location.href
                    };
                    return buildGroupsUrl(false, 'updateLink', queryString);
                }
                ,'showPhoto': function(groupKey, galleryKey, photoKey, slideshowOnPage, commentKey) {
                    var queryString = {
                        'slGroupKey': groupKey,
						'slGalleryKey': galleryKey,
                        'slMediaKey': photoKey,
						'slMediaType': 'photo',
						'plckFindCommentKey': safeString(commentKey)
                    };
                    if (slideshowOnPage) {
                        queryString['slSlideshowOnPage'] = slideshowOnPage;
                    }
                    return buildGroupsUrl(true, 'showPhoto', queryString);
                }
                ,'showVideo': function(groupKey, galleryKey, videoKey, slideshowOnPage, commentKey) {
                    var queryString = {
                        'slGroupKey': groupKey,
						'slGalleryKey': galleryKey,
                        'slMediaKey': videoKey,
						'slMediaType': 'video',
						'plckFindCommentKey': safeString(commentKey)
                    };
                    if (slideshowOnPage) {
                        queryString['slSlideshowOnPage'] = slideshowOnPage;
                    }
                    return buildGroupsUrl(true, 'showVideo', queryString);
                }
				,'updatePhoto': function(groupKey, galleryKey, photoKeyArray, editMode) {
					return buildGroupsUrl(true, 'updatePhoto', {
						'slGroupKey': groupKey,
						'slGalleryKey': galleryKey,
						'slMediaKeyArray': photoKeyArray,
						'slMediaType': 'photo',
						'slEditMode': editMode
					});
				}
				,'updateVideo': function(groupKey, galleryKey, videoKeyArray, editMode) {
					return buildGroupsUrl(true, 'updateVideo', {
						'slGroupKey': groupKey,
						'slGalleryKey': galleryKey,
						'slMediaKeyArray': videoKeyArray,
						'slMediaType': 'video',
						'slEditMode': editMode
					});
				}
                ,'showGallery': function(groupKey, galleryKey, mediaType, showUpload) {
                    if (typeof(showUpload) === 'undefined') {
                        showUpload = false;
                    }
                    return buildGroupsUrl(true, 'showGallery', {
                        'slGroupKey': groupKey,
                        'slGalleryKey': galleryKey,
                        'slMediaType': mediaType,
                        'slShowUpload': showUpload
                    });
                }
                ,'showBlog': function(groupKey, blogKey, showNewPost, postNotFoundError) {
                    var params = {
                        'slGroupKey': groupKey,
                        'slBlogKey': blogKey
                    };
                    if (showNewPost) {
                        params["slShowNewPost"] = showNewPost;
                    }
                    if (postNotFoundError) {
                        params["slPostNotFound"] = postNotFoundError;
                    }
                                        
                    return buildGroupsUrl(true, 'showBlog', params);
                }
                ,'showBlogPostsByTag': function(groupKey, blogKey, tag) {
                    return buildGroupsUrl(true, 'showBlog', {
                        'slGroupKey': groupKey,
                        'slBlogKey': blogKey,
                        'slTagFilter': tag
                    });
                }
                ,'showBlogPostsByArchiveMonth': function(groupKey, blogKey, archiveMonth) {
                    return buildGroupsUrl(true, 'showBlog', {
                        'slGroupKey': groupKey,
                        'slBlogKey': blogKey,
                        'slArchiveMonth': archiveMonth
                    })
                }
                ,'showBlogPost': function(groupKey, blogKey, blogPostKey, commentKey) {
                    return buildGroupsUrl(true, 'showBlogPost', {
                        'slGroupKey': groupKey,
                        'slBlogKey' : blogKey,
                        'slBlogPostKey': blogPostKey,
						'plckFindCommentKey': safeString(commentKey)
                    });
                }
                ,'editBlogPost': function(groupKey, blogPostKey) {
                    return buildGroupsUrl(true, 'editBlogPost', {
                        'slGroupKey' : groupKey,
                        'slBlogPostKey' : blogPostKey
                    });
                }
                ,'showForumDiscussion': function(groupKey, forumDiscussionKey, showNewDiscussion) {
                    if (typeof(showNewDiscussion) === 'undefined') {
                        showNewDiscussion = false;
                    }
                    return buildGroupsUrl(true, 'showDiscussion', {
                        'slGroupKey': groupKey,
                        'slForumDiscussionKey': forumDiscussionKey,
                        'slShowNewDiscussion': showNewDiscussion
                    });
                }
                ,'showEvent': function(groupKey, eventKey) {
                    return buildGroupsUrl(true, 'showEvent', {
                        'slGroupKey': groupKey
                    }, eventKey);
                }
                ,'showForumPost': function(groupKey, forumPostKey, onPage, gotoPostKey, sortOrder) {
					var params = {
                        'slGroupKey': groupKey,
                        'slForumPostKey': forumPostKey,
                        'onPage': onPage
                    };
					if(gotoPostKey && gotoPostKey != null){
						params['onPage'] = 0;
						params['plckFindPostKey'] = safeString(gotoPostKey);
					}
					else if(!onPage){
						params['onPage'] = 1;
					}
					else if(sortOrder) {
						params['sortOrder'] = safeString(sortOrder);
					}
					
                    return buildGroupsUrl(true, 'showDiscussionPost', params);
                }
                ,'updateEvent': function(groupKey, eventKey, cancelUrl) {
                    // default to current location if cancelUrl not given
                    var queryString = { 
                        'slGroupKey': (groupKey ? groupKey : ''),
                        'slEventKey': (eventKey ? eventKey : ''),
                        'slCancelUrl' : cancelUrl ? cancelUrl : window.location.href
                    };
                    return buildGroupsUrl(true, 'updateEvent', queryString);
                }
                ,'eventList': function(groupKey) {
                    return buildGroupsUrl(true, 'eventList', {
                        'slGroupKey': groupKey
                    });
                }
                ,'requestGroupDeletion': function(groupKey, cancelUrl) {
                    var queryString = {
                        'slGroupKey': safeString(groupKey),
                        'slCancelUrl' : cancelUrl ? cancelUrl : window.location.href
                    };
                    return buildGroupsUrl(false, 'requestGroupDeletion', queryString);
                }
                ,'inviteFriend': function(groupKey, cancelUrl){
                    var queryString = {
                        'slGroupKey': safeString(groupKey),
                        'slCancelUrl' : cancelUrl ? cancelUrl : window.location.href
                    };
                    return buildGroupsUrl(true, 'inviteFriend', queryString);
                }
            }
			,'privateMessaging': {
				'folder': function(folderId, notification) {
					var queryString = {
						'slFolderId': safeString(folderId)
					};
					if (notification)
						queryString['slNotification'] = notification;

					return buildPrivateMessagingUrl('folder', queryString);
				}
				,'compose': function(replyMessageId, replyFolderId, replyType) {
					var queryString = {};
					if (replyMessageId)
						queryString['slReplyMessageId'] = safeString(replyMessageId);
					if (replyType)
						queryString['slReplyType'] = safeString(replyType);
					if (replyFolderId)
						queryString["slReplyFolderId"] = safeString(replyFolderId);
					return buildPrivateMessagingUrl('compose', queryString);
				}
				,'composeWithTo': function(toUserKey, forumSubject, forumUrl) {
					var queryString = {
						'slSeedUserId': safeString(toUserKey),
						'slForumMessageSubject': safeString(forumSubject),
						'slForumUrl': safeString(forumUrl)
					};
					return buildPrivateMessagingUrl('compose', queryString);
				}
				,'message': function(messageId, folderId) {
					var queryString = {
						'slMessageId': safeString(messageId),
						'slFolderId': safeString(folderId)
					};
					return buildPrivateMessagingUrl('message', queryString);
				}
				,'contacts': function() {
					var queryString = {
					};
					return buildPrivateMessagingUrl('contacts', queryString);
				}
			}
            ,'personas': {
                'home': function(userKey) {
                    var queryString = {};
                    queryString[PLUCKSL_GLOBAL_OPTIONS.userIdQueryParamName] = userKey;
                    return slwidgets.slUtils.buildUrl(combinePath(PLUCKSL_GLOBAL_OPTIONS.baseUrl, PLUCKSL_GLOBAL_OPTIONS.personaSuffix), null, queryString);
                }
                ,'publicMessages': function(userKey) {
                    var queryString = {};
                    queryString[PLUCKSL_GLOBAL_OPTIONS.userIdQueryParamName] = userKey;
                    queryString['plckPersonaPage'] = 'PersonaMessages';
                    return slwidgets.slUtils.buildUrl(combinePath(PLUCKSL_GLOBAL_OPTIONS.baseUrl, PLUCKSL_GLOBAL_OPTIONS.personaSuffix), null, queryString);
                }
            }
            ,'admin': {
                'overview': function() {
                    return slwidgets.slUtils.buildUrl(combinePath(PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl, 'CMW/Overview'), null, null);
                }
            }
            , 'slScript' : function(scriptName){
                return combinePath(combinePath(PLUCKSL_GLOBAL_OPTIONS.siteLifeBaseUrl, PLUCKSL_GLOBAL_OPTIONS.siteLifeScriptsSuffix), scriptName);
            }
            ,'login': function(redirectUrl) {
                var redirectParams = {};
                if (redirectUrl) {
                    redirectParams[PLUCKSL_GLOBAL_OPTIONS.loginUrlRedirectQueryParamName] = redirectUrl;
                }
                return slwidgets.slUtils.buildUrl(PLUCKSL_GLOBAL_OPTIONS.loginUrl, null, redirectParams);
            }
            ,'logout': function(redirectUrl) {
                var redirectParams = {};
                if (redirectUrl) {
                    redirectParams[PLUCKSL_GLOBAL_OPTIONS.logoutUrlRedirectQueryParamName] = redirectUrl;
                }
                return slwidgets.slUtils.buildUrl(PLUCKSL_GLOBAL_OPTIONS.logoutUrl, null, redirectParams);
            }
            ,'register': function(redirectUrl) {
                var redirectParams = {};
                if (redirectUrl) {
                    redirectParams[PLUCKSL_GLOBAL_OPTIONS.registerUrlRedirectQueryParamName] = redirectUrl;
                }
                return slwidgets.slUtils.buildUrl(PLUCKSL_GLOBAL_OPTIONS.registerUrl, null, redirectParams);
            }
        }
    })();
}
/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov Nilz�n and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */


/* ******************* */
/* Constructor & Init  */
/* ******************* */

var SWFUpload = function (settings) {
	this.initSWFUpload(settings);
};

SWFUpload.prototype.initSWFUpload = function (settings) {
	try {
		this.customSettings = {};	// A container where developers can place their own settings associated with this instance.
		this.settings = settings;
		this.eventQueue = [];
		this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
		this.movieElement = null;

		// Setup global control tracking
		SWFUpload.instances[this.movieName] = this;

		// Load the settings.  Load the Flash movie.
		this.initSettings();
		this.loadFlash();
		this.displayDebugInfo();
	} catch (ex) {
		delete SWFUpload.instances[this.movieName];
		throw ex;
	}
};

/* *************** */
/* Static Members  */
/* *************** */
SWFUpload.instances = {};
SWFUpload.movieCount = 0;
SWFUpload.version = "2.2.0 Alpha";
SWFUpload.QUEUE_ERROR = {
	QUEUE_LIMIT_EXCEEDED	  		: -100,
	FILE_EXCEEDS_SIZE_LIMIT  		: -110,
	ZERO_BYTE_FILE			  		: -120,
	INVALID_FILETYPE		  		: -130
};
SWFUpload.UPLOAD_ERROR = {
	HTTP_ERROR				  		: -200,
	MISSING_UPLOAD_URL	      		: -210,
	IO_ERROR				  		: -220,
	SECURITY_ERROR			  		: -230,
	UPLOAD_LIMIT_EXCEEDED	  		: -240,
	UPLOAD_FAILED			  		: -250,
	SPECIFIED_FILE_ID_NOT_FOUND		: -260,
	FILE_VALIDATION_FAILED	  		: -270,
	FILE_CANCELLED			  		: -280,
	UPLOAD_STOPPED					: -290
};
SWFUpload.FILE_STATUS = {
	QUEUED		 : -1,
	IN_PROGRESS	 : -2,
	ERROR		 : -3,
	COMPLETE	 : -4,
	CANCELLED	 : -5
};
SWFUpload.BUTTON_ACTION = {
	SELECT_FILE  : -100,
	SELECT_FILES : -110,
	START_UPLOAD : -120
};
SWFUpload.CURSOR = {
	ARROW : -1,
	HAND : -2
};

/* ******************** */
/* Instance Members  */
/* ******************** */

// Private: initSettings ensures that all the
// settings are set, getting a default value if one was not assigned.
SWFUpload.prototype.initSettings = function () {
	this.ensureDefault = function (settingName, defaultValue) {
		this.settings[settingName] = (this.settings[settingName] == undefined) ? defaultValue : this.settings[settingName];
	};
	
	// Upload backend settings
	this.ensureDefault("upload_url", "");
	this.ensureDefault("file_post_name", "Filedata");
	this.ensureDefault("post_params", {});
	this.ensureDefault("use_query_string", false);
	this.ensureDefault("requeue_on_error", false);
	
	// File Settings
	this.ensureDefault("file_types", "*.*");
	this.ensureDefault("file_types_description", "All Files");
	this.ensureDefault("file_size_limit", 0);	// Default zero means "unlimited"
	this.ensureDefault("file_upload_limit", 0);
	this.ensureDefault("file_queue_limit", 0);

	// Flash Settings
	this.ensureDefault("flash_url", "swfupload.swf");
	this.ensureDefault("prevent_swf_caching", false);

	// Button Settings
	this.ensureDefault("button_image_url", 0);
	this.ensureDefault("button_width", 1);
	this.ensureDefault("button_height", 1);
	this.ensureDefault("button_text", "");
	this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
	this.ensureDefault("button_text_top_padding", 0);
	this.ensureDefault("button_text_left_padding", 0);
	this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
	this.ensureDefault("button_disabled", false);
	this.ensureDefault("button_placeholder_id", null);
	this.ensureDefault("button_cursor", SWFUpload.CURSOR.HAND);
	
	// Debug Settings
	this.ensureDefault("debug", false);
	this.settings.debug_enabled = this.settings.debug;	// Here to maintain v2 API
	
	// Event Handlers
	this.settings.return_upload_start_handler = this.returnUploadStart;
	this.ensureDefault("swfupload_loaded_handler", null);
	this.ensureDefault("file_dialog_start_handler", null);
	this.ensureDefault("file_queued_handler", null);
	this.ensureDefault("file_queue_error_handler", null);
	this.ensureDefault("file_dialog_complete_handler", null);
	
	this.ensureDefault("upload_start_handler", null);
	this.ensureDefault("upload_progress_handler", null);
	this.ensureDefault("upload_error_handler", null);
	this.ensureDefault("upload_success_handler", null);
	this.ensureDefault("upload_complete_handler", null);
	
	this.ensureDefault("debug_handler", this.debugMessage);

	this.ensureDefault("custom_settings", {});

	// Other settings
	this.customSettings = this.settings.custom_settings;
	
	delete this.ensureDefault;
};

SWFUpload.prototype.loadFlash = function () {
	
	if (this.settings.button_placeholder_id !== "") {
		this.replaceWithFlash();
	} else {
		this.appendFlash();
	}
};

// Private: appendFlash gets the HTML tag for the Flash
// It then appends the flash to the body
SWFUpload.prototype.appendFlash = function () {
	var targetElement, container;

	// Make sure an element with the ID we are going to use doesn't already exist
	if (document.getElementById(this.movieName) !== null) {
		throw "ID " + this.movieName + " is already in use. The Flash Object could not be added";
	}

	// Get the body tag where we will be adding the flash movie
	targetElement = document.getElementsByTagName("body")[0];

	if (targetElement == undefined) {
		throw "Could not find the 'body' element.";
	}

	// Append the container and load the flash
	container = document.createElement("div");
	container.style.width = "1px";
	container.style.height = "1px";
	container.style.overflow = "hidden";

	targetElement.appendChild(container);
	container.innerHTML = this.getFlashHTML();	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
};

// Private: replaceWithFlash replaces the button_placeholder element with the flash movie.
SWFUpload.prototype.replaceWithFlash = function () {
	
	var targetElement, tempParent;

	// Make sure an element with the ID we are going to use doesn't already exist
	if (document.getElementById(this.movieName) !== null) {
		throw "ID " + this.movieName + " is already in use. The Flash Object could not be added";
	}

	// Get the element where we will be placing the flash movie
	targetElement = document.getElementById(this.settings.button_placeholder_id);

	if (targetElement == undefined) {
		throw "Could not find the placeholder element.";
	}

	// Append the container and load the flash
	tempParent = document.createElement("div");
	tempParent.innerHTML = this.getFlashHTML();	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
	targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);
	//targetElement.innerHTML = this.getFlashHTML();
	
	// Fix IE Flash/Form bug
	if (window[this.movieName] == undefined) {
		window[this.movieName] = this.getMovieElement();
	}

};

// Private: getFlashHTML generates the object tag needed to embed the flash in to the document
SWFUpload.prototype.getFlashHTML = function () {

	var flash_url = this.settings.flash_url + (this.settings.prevent_swf_caching ? ("?swfuploadrnd=" + Math.random() * 999999999) : "");
	
	// Flash Satay object syntax: http://www.alistapart.com/articles/flashsatay
	return ['<object id="', this.movieName, '" type="application/x-shockwave-flash" data="', flash_url, '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
				'<param name="movie" value="', this.settings.flash_url, '" />',
				'<param name="quality" value="high" />',
				'<param name="menu" value="false" />',
				'<param name="allowScriptAccess" value="always" />',
				'<param name="flashvars" value="' + this.getFlashVars() + '" />',
				'<param name="wmode" value="transparent"/>',
				'</object>'].join("");
};

// Private: getFlashVars builds the parameter string that will be passed
// to flash in the flashvars param.
SWFUpload.prototype.getFlashVars = function () {
	// Build a string from the post param object
	var paramString = this.buildParamString();

	// Build the parameter string
	return ["movieName=", encodeURIComponent(this.movieName),
			"&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
			"&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
			"&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
			"&amp;params=", encodeURIComponent(paramString),
			"&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
			"&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
			"&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
			"&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
			"&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
			"&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
			"&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
			"&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
			"&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
			"&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
			"&amp;buttonText=", encodeURIComponent(this.settings.button_text),
			"&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
			"&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
			"&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
			"&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
			"&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
			"&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
		].join("");
};

// Public: getMovieElement retrieves the DOM reference to the Flash element added by SWFUpload
// The element is cached after the first lookup
SWFUpload.prototype.getMovieElement = function () {
	if (this.movieElement == undefined) {
		this.movieElement = document.getElementById(this.movieName);
	}

	if (this.movieElement === null) {
		throw "Could not find Flash element";
	}
	return this.movieElement;
};

// Private: buildParamString takes the name/value pairs in the post_params setting object
// and joins them up in to a string formatted "name=value&amp;name=value"
SWFUpload.prototype.buildParamString = function () {
	var postParams = this.settings.post_params; 
	var paramStringPairs = [];

	if (typeof(postParams) === "object") {
		for (var name in postParams) {
			if (postParams.hasOwnProperty(name)) {
				paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
			}
		}
	}

	return paramStringPairs.join("&amp;");
};

// Public: Used to remove a SWFUpload instance from the page. This method strives to remove
// all references to the SWF, and other objects so memory is properly freed.
// Returns true if everything was destroyed. Returns a false if a failure occurs leaving SWFUpload in an inconsistant state.
SWFUpload.prototype.destroy = function () {
	try {
		// Make sure Flash is done before we try to remove it
		this.stopUpload();
		
		// Remove the SWFUpload DOM nodes
		var movieElement = null;
		try {
			movieElement = this.getMovieElement();
		} catch (ex) {
		}
		
		if (movieElement != undefined && movieElement.parentNode != undefined && typeof movieElement.parentNode.removeChild === "function") {
			var container = movieElement.parentNode;
			if (container != undefined) {
				container.removeChild(movieElement);
				if (container.parentNode != undefined && typeof container.parentNode.removeChild === "function") {
					container.parentNode.removeChild(container);
				}
			}
		}
		
		// Destroy references
		SWFUpload.instances[this.movieName] = null;
		delete SWFUpload.instances[this.movieName];

		delete this.movieElement;
		delete this.settings;
		delete this.customSettings;
		delete this.eventQueue;
		delete this.movieName;
		
		delete window[this.movieName];
		
		return true;
	} catch (ex1) {
		return false;
	}
};

// Public: displayDebugInfo prints out settings and configuration
// information about this SWFUpload instance.
// This function (and any references to it) can be deleted when placing
// SWFUpload in production.
SWFUpload.prototype.displayDebugInfo = function () {
	this.debug(
		[
			"---SWFUpload Instance Info---\n",
			"Version: ", SWFUpload.version, "\n",
			"Movie Name: ", this.movieName, "\n",
			"Settings:\n",
			"\t", "upload_url:               ", this.settings.upload_url, "\n",
			"\t", "flash_url:                ", this.settings.flash_url, "\n",
			"\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
			"\t", "file_post_name:           ", this.settings.file_post_name, "\n",
			"\t", "post_params:              ", this.settings.post_params.toString(), "\n",
			"\t", "file_types:               ", this.settings.file_types, "\n",
			"\t", "file_types_description:   ", this.settings.file_types_description, "\n",
			"\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
			"\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
			"\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
			"\t", "debug:                    ", this.settings.debug.toString(), "\n",

			"\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

			"\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
			"\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
			"\t", "button_width:             ", this.settings.button_width.toString(), "\n",
			"\t", "button_height:            ", this.settings.button_height.toString(), "\n",
			"\t", "button_text:              ", this.settings.button_text.toString(), "\n",
			"\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
			"\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
			"\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
			"\t", "button_action:            ", this.settings.button_action.toString(), "\n",
			"\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

			"\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
			"Event Handlers:\n",
			"\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
			"\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
			"\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
			"\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
			"\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
			"\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
			"\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
			"\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
			"\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
			"\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n"
		].join("")
	);
};

/* Note: addSetting and getSetting are no longer used by SWFUpload but are included
	the maintain v2 API compatibility
*/
// Public: (Deprecated) addSetting adds a setting value. If the value given is undefined or null then the default_value is used.
SWFUpload.prototype.addSetting = function (name, value, default_value) {
    if (value == undefined) {
        return (this.settings[name] = default_value);
    } else {
        return (this.settings[name] = value);
	}
};

// Public: (Deprecated) getSetting gets a setting. Returns an empty string if the setting was not found.
SWFUpload.prototype.getSetting = function (name) {
    if (this.settings[name] != undefined) {
        return this.settings[name];
	}

    return "";
};



// Private: callFlash handles function calls made to the Flash element.
// Calls are made with a setTimeout for some functions to work around
// bugs in the ExternalInterface library.
SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
	argumentArray = argumentArray || [];
	
	var self = this;
	var callFunction = function () {
		var movieElement = self.getMovieElement();
		var returnValue;
		if (typeof movieElement[functionName] === "function") {
			// We have to go through all this if/else stuff because the Flash functions don't have apply() and only accept the exact number of arguments.
			if (argumentArray.length === 0) {
				returnValue = movieElement[functionName]();
			} else if (argumentArray.length === 1) {
				returnValue = movieElement[functionName](argumentArray[0]);
			} else if (argumentArray.length === 2) {
				returnValue = movieElement[functionName](argumentArray[0], argumentArray[1]);
			} else if (argumentArray.length === 3) {
				returnValue = movieElement[functionName](argumentArray[0], argumentArray[1], argumentArray[2]);
			} else {
				throw "Too many arguments";
			}
			
			// Unescape file post param values
			if (returnValue != undefined && typeof returnValue.post === "object") {
				returnValue = self.unescapeFilePostParams(returnValue);
			}
			
			return returnValue;
		} else {
			throw "Invalid function name";
		}
	};
	
	return callFunction();
};


/* *****************************
	-- Flash control methods --
	Your UI should use these
	to operate SWFUpload
   ***************************** */

// Public: selectFile causes a File Selection Dialog window to appear.  This
// dialog only allows 1 file to be selected. WARNING: this function does not work in Flash Player 10
SWFUpload.prototype.selectFile = function () {
	this.callFlash("SelectFile");
};

// Public: selectFiles causes a File Selection Dialog window to appear/ This
// dialog allows the user to select any number of files
// Flash Bug Warning: Flash limits the number of selectable files based on the combined length of the file names.
// If the selection name length is too long the dialog will fail in an unpredictable manner.  There is no work-around
// for this bug.  WARNING: this function does not work in Flash Player 10
SWFUpload.prototype.selectFiles = function () {
	this.callFlash("SelectFiles");
};


// Public: startUpload starts uploading the first file in the queue unless
// the optional parameter 'fileID' specifies the ID 
SWFUpload.prototype.startUpload = function (fileID) {
	this.callFlash("StartUpload", [fileID]);
};

/* Cancels a the file upload.  You must specify a file_id */
// Public: cancelUpload cancels any queued file.  The fileID parameter
// must be specified.
SWFUpload.prototype.cancelUpload = function (fileID) {
	this.callFlash("CancelUpload", [fileID]);
};

// Public: stopUpload stops the current upload and requeues the file at the beginning of the queue.
// If nothing is currently uploading then nothing happens.
SWFUpload.prototype.stopUpload = function () {
	this.callFlash("StopUpload");
};

/* ************************
 * Settings methods
 *   These methods change the SWFUpload settings.
 *   SWFUpload settings should not be changed directly on the settings object
 *   since many of the settings need to be passed to Flash in order to take
 *   effect.
 * *********************** */

// Public: getStats gets the file statistics object.
SWFUpload.prototype.getStats = function () {
	return this.callFlash("GetStats");
};

// Public: setStats changes the SWFUpload statistics.  You shouldn't need to 
// change the statistics but you can.  Changing the statistics does not
// affect SWFUpload accept for the successful_uploads count which is used
// by the upload_limit setting to determine how many files the user may upload.
SWFUpload.prototype.setStats = function (statsObject) {
	this.callFlash("SetStats", [statsObject]);
};

// Public: getFile retrieves a File object by ID or Index.  If the file is
// not found then 'null' is returned.
SWFUpload.prototype.getFile = function (fileID) {
	if (typeof(fileID) === "number") {
		return this.callFlash("GetFileByIndex", [fileID]);
	} else {
		return this.callFlash("GetFile", [fileID]);
	}
};

// Public: addFileParam sets a name/value pair that will be posted with the
// file specified by the Files ID.  If the name already exists then the
// exiting value will be overwritten.
SWFUpload.prototype.addFileParam = function (fileID, name, value) {
	return this.callFlash("AddFileParam", [fileID, name, value]);
};

// Public: removeFileParam removes a previously set (by addFileParam) name/value
// pair from the specified file.
SWFUpload.prototype.removeFileParam = function (fileID, name) {
	this.callFlash("RemoveFileParam", [fileID, name]);
};

// Public: setUploadUrl changes the upload_url setting.
SWFUpload.prototype.setUploadURL = function (url) {
	this.settings.upload_url = url.toString();
	this.callFlash("SetUploadURL", [url]);
};

// Public: setPostParams changes the post_params setting
SWFUpload.prototype.setPostParams = function (paramsObject) {
	this.settings.post_params = paramsObject;
	this.callFlash("SetPostParams", [paramsObject]);
};

// Public: addPostParam adds post name/value pair.  Each name can have only one value.
SWFUpload.prototype.addPostParam = function (name, value) {
	this.settings.post_params[name] = value;
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: removePostParam deletes post name/value pair.
SWFUpload.prototype.removePostParam = function (name) {
	delete this.settings.post_params[name];
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: setFileTypes changes the file_types setting and the file_types_description setting
SWFUpload.prototype.setFileTypes = function (types, description) {
	this.settings.file_types = types;
	this.settings.file_types_description = description;
	this.callFlash("SetFileTypes", [types, description]);
};

// Public: setFileSizeLimit changes the file_size_limit setting
SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
	this.settings.file_size_limit = fileSizeLimit;
	this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
};

// Public: setFileUploadLimit changes the file_upload_limit setting
SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
	this.settings.file_upload_limit = fileUploadLimit;
	this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
};

// Public: setFileQueueLimit changes the file_queue_limit setting
SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
	this.settings.file_queue_limit = fileQueueLimit;
	this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
};

// Public: setFilePostName changes the file_post_name setting
SWFUpload.prototype.setFilePostName = function (filePostName) {
	this.settings.file_post_name = filePostName;
	this.callFlash("SetFilePostName", [filePostName]);
};

// Public: setUseQueryString changes the use_query_string setting
SWFUpload.prototype.setUseQueryString = function (useQueryString) {
	this.settings.use_query_string = useQueryString;
	this.callFlash("SetUseQueryString", [useQueryString]);
};

// Public: setRequeueOnError changes the requeue_on_error setting
SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
	this.settings.requeue_on_error = requeueOnError;
	this.callFlash("SetRequeueOnError", [requeueOnError]);
};

// Public: setDebugEnabled changes the debug_enabled setting
SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
	this.settings.debug_enabled = debugEnabled;
	this.callFlash("SetDebugEnabled", [debugEnabled]);
};

// Public: setButtonImageURL loads a button image sprite
SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
	this.settings.button_image_url = buttonImageURL;
	this.callFlash("SetButtonImageURL", [buttonImageURL]);
};

// Public: setButtonDimensions resizes the Flash Movie and button
SWFUpload.prototype.setButtonDimensions = function (width, height) {
	this.settings.button_width = width;
	this.settings.button_height = height;
	
	var movie = this.getMovieElement();
	if (movie != undefined) {
		movie.style.width = width + "px";
		movie.style.height = (Math.floor(height / 4)) + "px";
	}
	
	this.callFlash("SetButtonDimensions", [width, height]);
};
// Public: setButtonText Changes the text overlaid on the button
SWFUpload.prototype.setButtonText = function (html) {
	this.settings.button_text = html;
	this.callFlash("SetButtonText", [html]);
};
// Public: setButtonTextPadding changes the top and left padding of the text overlay
SWFUpload.prototype.setButtonTextPadding = function (left, top) {
	this.settings.button_text_top_padding = top;
	this.settings.button_text_left_padding = left;
	this.callFlash("SetButtonTextPadding", [left, top]);
};

// Public: setButtonTextStyle changes the CSS used to style the HTML/Text overlaid on the button
SWFUpload.prototype.setButtonTextStyle = function (css) {
	this.settings.button_text_style = css;
	this.callFlash("SetButtonTextStyle", [css]);
};
// Public: setButtonDisabled disables/enables the button
SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
	this.settings.button_disabled = isDisabled;
	this.callFlash("SetButtonDisabled", [isDisabled]);
};
// Public: setButtonAction sets the action that occurs when the button is clicked
SWFUpload.prototype.setButtonAction = function (buttonAction) {
	this.settings.button_action = buttonAction;
	this.callFlash("SetButtonAction", [buttonAction]);
};

// Public: setButtonCursor changes the mouse cursor displayed when hovering over the button
SWFUpload.prototype.setButtonCursor = function (cursor) {
	this.settings.button_cursor = cursor;
	this.callFlash("SetButtonCursor", [cursor]);
};

/* *******************************
	Flash Event Interfaces
	These functions are used by Flash to trigger the various
	events.
	
	All these functions a Private.
	
	Because the ExternalInterface library is buggy the event calls
	are added to a queue and the queue then executed by a setTimeout.
	This ensures that events are executed in a determinate order and that
	the ExternalInterface bugs are avoided.
******************************* */

SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop
	
	if (argumentArray == undefined) {
		argumentArray = [];
	} else if (!(argumentArray instanceof Array)) {
		argumentArray = [argumentArray];
	}
	
	var self = this;
	if (typeof this.settings[handlerName] === "function") {
		// Queue the event
		this.eventQueue.push(function () {
			this.settings[handlerName].apply(this, argumentArray);
		});
		
		// Execute the next queued event
		setTimeout(function () {
			self.executeNextEvent();
		}, 0);
		
	} else if (this.settings[handlerName] !== null) {
		throw "Event handler " + handlerName + " is unknown or is not a function";
	}
};

// Private: Causes the next event in the queue to be executed.  Since events are queued using a setTimeout
// we must queue them in order to garentee that they are executed in order.
SWFUpload.prototype.executeNextEvent = function () {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop

	var  f = this.eventQueue ? this.eventQueue.shift() : null;
	if (typeof(f) === "function") {
		f.apply(this);
	}
};

// Private: unescapeFileParams is part of a workaround for a flash bug where objects passed through ExternalInterface cannot have
// properties that contain characters that are not valid for JavaScript identifiers. To work around this
// the Flash Component escapes the parameter names and we must unescape again before passing them along.
SWFUpload.prototype.unescapeFilePostParams = function (file) {
	var reg = /[$]([0-9a-f]{4})/i;
	var unescapedPost = {};
	var uk;

	if (file != undefined) {
		for (var k in file.post) {
			if (file.post.hasOwnProperty(k)) {
				uk = k;
				var match;
				while ((match = reg.exec(uk)) !== null) {
					uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
				}
				unescapedPost[uk] = file.post[k];
			}
		}

		file.post = unescapedPost;
	}

	return file;
};

SWFUpload.prototype.flashReady = function () {
	// Check that the movie element is loaded correctly with its ExternalInterface methods defined
	var movieElement = this.getMovieElement();
	if (typeof movieElement.StartUpload !== "function") {
		throw "ExternalInterface methods failed to initialize.";
	}
	
	this.queueEvent("swfupload_loaded_handler");
};


/* This is a chance to do something before the browse window opens */
SWFUpload.prototype.fileDialogStart = function () {
	this.queueEvent("file_dialog_start_handler");
};


/* Called when a file is successfully added to the queue. */
SWFUpload.prototype.fileQueued = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queued_handler", file);
};


/* Handle errors that occur when an attempt to queue a file fails. */
SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
};

/* Called after the file dialog has closed and the selected files have been queued.
	You could call startUpload here if you want the queued files to begin uploading immediately. */
SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued) {
	this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued]);
};

SWFUpload.prototype.uploadStart = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("return_upload_start_handler", file);
};

SWFUpload.prototype.returnUploadStart = function (file) {
	var returnValue;
	if (typeof this.settings.upload_start_handler === "function") {
		file = this.unescapeFilePostParams(file);
		returnValue = this.settings.upload_start_handler.call(this, file);
	} else if (this.settings.upload_start_handler != undefined) {
		throw "upload_start_handler must be a function";
	}

	// Convert undefined to true so if nothing is returned from the upload_start_handler it is
	// interpretted as 'true'.
	if (returnValue === undefined) {
		returnValue = true;
	}
	
	returnValue = !!returnValue;
	
	this.callFlash("ReturnUploadStart", [returnValue]);
};



SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
};

SWFUpload.prototype.uploadError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_error_handler", [file, errorCode, message]);
};

SWFUpload.prototype.uploadSuccess = function (file, serverData) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_success_handler", [file, serverData]);
};

SWFUpload.prototype.uploadComplete = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_complete_handler", file);
};

/* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
   internal debug console.  You can override this event and have messages written where you want. */
SWFUpload.prototype.debug = function (message) {
	this.queueEvent("debug_handler", message);
};


/* **********************************
	Debug Console
	The debug console is a self contained, in page location
	for debug message to be sent.  The Debug Console adds
	itself to the body if necessary.

	The console is automatically scrolled as messages appear.
	
	If you are using your own debug handler or when you deploy to production and
	have debug disabled you can remove these functions to reduce the file size
	and complexity.
********************************** */
   
// Private: debugMessage is the default debug_handler.  If you want to print debug messages
// call the debug() function.  When overriding the function your own function should
// check to see if the debug setting is true before outputting debug information.
SWFUpload.prototype.debugMessage = function (message) {
	if (this.settings.debug) {
		var exceptionMessage, exceptionValues = [];

		// Check for an exception object and print it nicely
		if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
			for (var key in message) {
				if (message.hasOwnProperty(key)) {
					exceptionValues.push(key + ": " + message[key]);
				}
			}
			exceptionMessage = exceptionValues.join("\n") || "";
			exceptionValues = exceptionMessage.split("\n");
			exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
			SWFUpload.Console.writeLine(exceptionMessage);
		} else {
			SWFUpload.Console.writeLine(message);
		}
	}
};

SWFUpload.Console = {};
SWFUpload.Console.writeLine = function (message) {
	var console, documentForm;

	try {
		console = document.getElementById("SWFUpload_Console");

		if (!console) {
			documentForm = document.createElement("form");
			document.getElementsByTagName("body")[0].appendChild(documentForm);

			console = document.createElement("textarea");
			console.id = "SWFUpload_Console";
			console.style.fontFamily = "monospace";
			console.setAttribute("wrap", "off");
			console.wrap = "off";
			console.style.overflow = "auto";
			console.style.width = "700px";
			console.style.height = "350px";
			console.style.margin = "5px";
			documentForm.appendChild(console);
		}

		console.value += message + "\n";

		console.scrollTop = console.scrollHeight - console.clientHeight;
	} catch (ex) {
		alert("Exception: " + ex.name + " Message: " + ex.message);
	}
};
/*
	Cookie Plug-in
	
	This plug in automatically gets all the cookies for this site and adds them to the post_params.
	Cookies are loaded only on initialization.  The refreshCookies function can be called to update the post_params.
	The cookies will override any other post params with the same name.
*/

var SWFUpload;
if (typeof(SWFUpload) === "function") {
	SWFUpload.prototype.initSettings = function (oldInitSettings) {
		return function () {
			if (typeof(oldInitSettings) === "function") {
				oldInitSettings.call(this);
			}
			
			this.refreshCookies(false);	// The false parameter must be sent since SWFUpload has not initialzed at this point
		};
	}(SWFUpload.prototype.initSettings);
	
	// refreshes the post_params and updates SWFUpload.  The sendToFlash parameters is optional and defaults to True
	SWFUpload.prototype.refreshCookies = function (sendToFlash) {
		if (sendToFlash === undefined) {
			sendToFlash = true;
		}
		sendToFlash = !!sendToFlash;
		
		// Get the post_params object
		var postParams = this.settings.post_params;
		
		// Get the cookies
		var i, cookieArray = document.cookie.split(';'), caLength = cookieArray.length, c, eqIndex, name, value;
		for (i = 0; i < caLength; i++) {
			c = cookieArray[i];
			
			// Left Trim spaces
			while (c.charAt(0) === " ") {
				c = c.substring(1, c.length);
			}
			eqIndex = c.indexOf("=");
			if (eqIndex > 0) {
				name = c.substring(0, eqIndex);
				value = c.substring(eqIndex + 1);
				postParams[name] = value;
			}
		}
		
		if (sendToFlash) {
			this.setPostParams(postParams);
		}
	};

}

